---
title: "GPIO"
date: 2025-11-05 09:19:34 +0800
categories: [Bare Metal STM32]
tags: [Bare Metal STM32]
---

# ðŸ“š STM32 GPIO Programming Guide

## ðŸ“Œ 1. Giá»›i thiá»‡u vá» GPIO
GPIO (General Purpose Input/Output) lÃ  cÃ¡c chÃ¢n vÃ o/ra Ä‘a nÄƒng trÃªn vi Ä‘iá»u khiá»ƒn STM32, cho phÃ©p tÆ°Æ¡ng tÃ¡c vá»›i tháº¿ giá»›i bÃªn ngoÃ i.

![alt text](/assets/Bare_Metal_STM32/GPIO/image.png)

### 1.1 Äáº·c Ä‘iá»ƒm cá»§a GPIO STM32
- CÃ³ thá»ƒ cáº¥u hÃ¬nh lÃ  input hoáº·c output
- Há»— trá»£ pull-up/pull-down
- Tá»‘c Ä‘á»™ Ä‘áº§u ra cÃ³ thá»ƒ Ä‘iá»u chá»‰nh
- Chá»©c nÄƒng alternate function
- Interrupt/Event handling

### 1.2 Cáº¥u trÃºc GPIO Port
![GPIO Port Structure](/assets/Bare_Metal_STM32/gpio_structure.png)

## ðŸ”§ 2. Thanh ghi GPIO

### 2.1 GPIO Port Mode Register (GPIOx_MODER)
```c
// CÃ¡c mode cÃ³ thá»ƒ:
#define GPIO_MODE_INPUT     0x00    // Input mode
#define GPIO_MODE_OUTPUT    0x01    // Output mode
#define GPIO_MODE_AF        0x02    // Alternate function
#define GPIO_MODE_ANALOG    0x03    // Analog mode
```

### 2.2 GPIO Output Type Register (GPIOx_OTYPER)
```c
// Kiá»ƒu Ä‘áº§u ra:
#define GPIO_OTYPE_PP       0x00    // Push-pull
#define GPIO_OTYPE_OD       0x01    // Open-drain
```

### 2.3 GPIO Pull-up/Pull-down Register (GPIOx_PUPDR)
```c
// Cáº¥u hÃ¬nh pull-up/down:
#define GPIO_PUPDR_NONE     0x00    // No pull-up, pull-down
#define GPIO_PUPDR_PU       0x01    // Pull-up
#define GPIO_PUPDR_PD       0x02    // Pull-down
```

### 2.4 GPIO Speed Register (GPIOx_OSPEEDR)
```c
// Tá»‘c Ä‘á»™ Ä‘áº§u ra:
#define GPIO_SPEED_LOW      0x00    // Low speed
#define GPIO_SPEED_MEDIUM   0x01    // Medium speed
#define GPIO_SPEED_HIGH     0x02    // High speed
#define GPIO_SPEED_VERY_HIGH 0x03   // Very high speed
```

## ðŸ’» 3. Láº­p trÃ¬nh GPIO

### 3.1 Cáº¥u hÃ¬nh GPIO
```c
void GPIO_Init(GPIO_TypeDef *GPIOx, uint8_t pin, uint8_t mode) {
    // Enable clock cho GPIO port
    if(GPIOx == GPIOA) RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    
    // Cáº¥u hÃ¬nh mode
    GPIOx->MODER &= ~(3UL << (2 * pin));           // Clear bits
    GPIOx->MODER |= (mode << (2 * pin));           // Set mode
}
```

### 3.2 Äiá»u khiá»ƒn Ä‘áº§u ra
```c
// Set pin high
static inline void GPIO_SetPin(GPIO_TypeDef *GPIOx, uint8_t pin) {
    GPIOx->BSRR = (1 << pin);
}

// Set pin low
static inline void GPIO_ResetPin(GPIO_TypeDef *GPIOx, uint8_t pin) {
    GPIOx->BSRR = (1 << (pin + 16));
}

// Toggle pin
static inline void GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint8_t pin) {
    GPIOx->ODR ^= (1 << pin);
}
```

### 3.3 Äá»c Ä‘áº§u vÃ o
```c
// Äá»c tráº¡ng thÃ¡i pin
static inline uint8_t GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint8_t pin) {
    return (GPIOx->IDR & (1 << pin)) ? 1 : 0;
}
```

## ðŸ”Œ 4. VÃ­ dá»¥ á»¨ng dá»¥ng

### 4.1 LED Blink
```c
int main(void) {
    // Cáº¥u hÃ¬nh LED pin (vÃ­ dá»¥: PA5)
    GPIO_Init(GPIOA, 5, GPIO_MODE_OUTPUT);
    
    while(1) {
        GPIO_TogglePin(GPIOA, 5);  // Toggle LED
        for(int i = 0; i < 1000000; i++); // Delay
    }
}
```

### 4.2 Äá»c nÃºt nháº¥n
```c
int main(void) {
    // Cáº¥u hÃ¬nh button (vÃ­ dá»¥: PC13)
    GPIO_Init(GPIOC, 13, GPIO_MODE_INPUT);
    // Cáº¥u hÃ¬nh LED (PA5)
    GPIO_Init(GPIOA, 5, GPIO_MODE_OUTPUT);
    
    while(1) {
        if(GPIO_ReadPin(GPIOC, 13) == 0) {  // Button pressed
            GPIO_SetPin(GPIOA, 5);           // Turn on LED
        } else {
            GPIO_ResetPin(GPIOA, 5);         // Turn off LED
        }
    }
}
```

## âš¡ 5. GPIO Interrupts

### 5.1 Cáº¥u hÃ¬nh Interrupt
```c
void GPIO_EnableInterrupt(GPIO_TypeDef *GPIOx, uint8_t pin, uint8_t edge) {
    // Enable SYSCFG clock
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
    
    // Cáº¥u hÃ¬nh EXTI line
    uint8_t portcode = ((uint32_t)GPIOx - GPIOA_BASE) / 0x400;
    SYSCFG->EXTICR[pin/4] &= ~(0xF << (4 * (pin % 4)));
    SYSCFG->EXTICR[pin/4] |= portcode << (4 * (pin % 4));
    
    // Cáº¥u hÃ¬nh trigger edge
    if(edge & 0x01) EXTI->RTSR |= (1 << pin);  // Rising edge
    if(edge & 0x02) EXTI->FTSR |= (1 << pin);  // Falling edge
    
    // Enable EXTI line
    EXTI->IMR |= (1 << pin);
    
    // Enable NVIC interrupt
    NVIC_EnableIRQ(EXTI15_10_IRQn);
}
```

### 5.2 Xá»­ lÃ½ Interrupt
```c
void EXTI15_10_IRQHandler(void) {
    if(EXTI->PR & (1 << 13)) {  // Check if EXTI13 triggered
        // Xá»­ lÃ½ interrupt
        
        // Clear interrupt flag
        EXTI->PR = (1 << 13);
    }
}
```

## ðŸ” 6. Best Practices

### 6.1 Tá»‘i Æ°u hiá»‡u nÄƒng
- Sá»­ dá»¥ng inline functions cho cÃ¡c thao tÃ¡c Ä‘Æ¡n giáº£n
- TrÃ¡nh polling liÃªn tá»¥c, sá»­ dá»¥ng interrupts
- Cáº¥u hÃ¬nh tá»‘c Ä‘á»™ GPIO phÃ¹ há»£p vá»›i á»©ng dá»¥ng

### 6.2 An toÃ n vÃ  Báº£o vá»‡
- Sá»­ dá»¥ng internal pull-up/down khi cáº§n thiáº¿t
- TrÃ¡nh floating inputs
- Báº£o vá»‡ GPIO khá»i quÃ¡ Ã¡p/quÃ¡ dÃ²ng

## ðŸ“š 7. TÃ i liá»‡u tham kháº£o
1. STM32 Reference Manual
2. STM32 Datasheet
3. Application Notes
4. Programming Manual

