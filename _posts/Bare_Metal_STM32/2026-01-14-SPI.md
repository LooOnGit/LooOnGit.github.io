---
title: "SPI"
date: 2026-01-14 20:53:06 +0700
categories: [Bare Metal STM32]
tags: [Bare Metal STM32]
---

# SPI

## Overview of  the SPI protocol
### What is SPI?
SPI là chuẩn giao tiếp đồng bộ (synchronous) được phát triển bởi Motorola. Khác với UART thì SPI có chân sign để đồng bộ data giữa các devices. Nó được thiết kế giao tiếp khoảng cách ngắn (thường ngắn hơn 30 cm).
### Key feature of SPI
- **Full-duplex communication**: SPI support đồng thời gửi và nhận dữ liệu.
- **High speed**: SPI có thể hoạt động tốc độ cao hơn so với các protocol như I2C và UART.
- **Master-slave architecture**: Một master device điều khiển giao tiếp, trong khi 1 hoặc nhiều slave devices phản hồi.
- **Flexible data lenght**: Có thể xử lý nhiều độ dài data, thông thường 8bit, nhưng không giới hạn.
### The SPI interface
- **Master In Slave Out (MISO)**: Còn được gọi là **Serial Data Out (SDO)** or **Data Out (DOUT)**, mang data từ slave đến master.
- **Master Out Slave In (MOSI)**: Còn được gọi là **Serial Data In (SDI)** or **Data In (DIN)**, mang data từ master đến slave.
- **Serial Clock (SCK)**: Cùng được xem như **SCLK**(hoặc cơ bản CLK), điều này clock signal để đồng bộ data gửi giữa master và slave.
- **Slave Select (SS)**: Cũng được gọi là **Chip Select (CS)** hoặc **Not Slave Select (NSS)**, sử dụng bằng master để chọn device để giao tiếp.


![SPI](/assets/Bare_Metal_STM32/SPI/image.png)


Khi nhiều slave được kết nối chung trên một bus SPI, việc quản lý đường MISO là cực kỳ quan trọng để tránh lỗi truyền thông. Vì tất cả các slave đều dùng chung đường này, các slave không được chọn có thể gây nhiễu tín hiệu của slave đang được chọn nếu không được kiểm soát đúng cách.


Để ngăn chặn các vấn đề này, người ta sử dụng nhiều kỹ thuật khác nhau. Một phương pháp phổ biến là tri-state buffering, trong đó chân MISO của mỗi slave sẽ chuyển sang trạng thái trở kháng cao (high-Z) khi chân CS của nó không được kích hoạt, tức là nó bị “ngắt” khỏi bus. Điều này đảm bảo rằng chỉ slave đang được chọn mới điều khiển đường MISO, tránh hiện tượng xung đột bus.


Một cách tiếp cận khác là cấu hình open-drain với điện trở kéo lên (pull-up resistor). Khi đó, đường MISO sẽ ở trạng thái “thả nổi” (high-Z) khi truyền bit 1, và chỉ bị kéo xuống mức thấp bởi slave đang được chọn khi truyền bit 0. Cách này giúp giảm nguy cơ xung đột, nhưng có thể làm tốc độ truyền chậm hơn do thời gian trễ của điện trở kéo lên.
### How SPI works
SPI làm việc theo nguyên tắc cơ bản: master tạo ra clock signal và chọn slave để giao tiếp với pull SS xuống mức thấp. Data thì sẽ được trao đổi đồng bộ giữa master và slaver thông qua MOSI và MISO.
- **1. Initialize SPI**: Master set tần số clock và data format (trong ví dụ, 8-bit).
- **2.Slave select**: Master kéo chân SS (Slave Select) của slave cần giao tiếp xuống mức thấp (LOW).
Trong cấu hình có nhiều slave, mỗi slave có một chân CS riêng, master trước tiên phải đặt tất cả các chân CS lên mức cao (HIGH – không hoạt động) trước khi gửi bất kỳ lệnh khởi tạo nào. Việc này đảm bảo rằng các slave chưa được khởi tạo sẽ không phản hồi nhầm các lệnh không dành cho chúng. Sau khi tất cả CS đã ở mức HIGH, master mới kéo CS của slave cần giao tiếp xuống LOW để bắt đầu truyền thông có kiểm soát.
- **3. Data transmission**: Master send data tới slave trên MOSI, trong khi slave send data tới master trên MISO.
- **4.Clock synchronization**: Master điều khiển xung clock, đảm bảo dữ liệu được lấy mẫu và dịch bit tại đúng thời điểm.
- **5. Completion**: Sau khi quá trình truyền dữ liệu hoàn tất, master kéo chân SS lên mức cao (HIGH) để bỏ chọn (deselect) slave.
### CPHA and CPOL
Trong giao thức SPI, set cho CPHA và CPOL để xác định timing và đặc tính của clock signal đã sử dụng để syn data gửi giữa master và slave device. Set này chủ yếu đẩm bảo rằng data được lấy mẫu (sample) và diễn giải cả 2 master và slave.
#### CPHA
CPHA xác định thời điểm dữ liệu được lấy mẫu và thời điểm dữ liệu được xuất ra. Nó quyết định cạnh (edge) của xung clock mà dữ liệu được đọc và ghi:
- **CPHA = 0**: Dữ liệu được lấy mẫu ở cạnh dẫn (leading edge – cạnh đầu tiên) của xung clock và dịch/ghi ra ở cạnh sau (trailing edge – cạnh thứ hai).
- **CPHA = 1**: Dữ liệu được dịch/ghi ra ở cạnh dẫn (leading edge) và lấy mẫu ở cạnh sau (trailing edge).
#### CPOL
CPOL xác định trạng thái nhàn rỗi (idle) của tín hiệu clock SCK. Nó quyết định mức logic của clock khi không có dữ liệu được truyền:
- **CPOL = 0**: Tín hiệu clock ở mức thấp (0) khi idle. Nghĩa là đường clock luôn ở mức thấp giữa các lần truyền dữ liệu.
- **CPOL = 1**: Tín hiệu clock ở mức cao (1) khi idle. Nghĩa là đường clock luôn ở mức cao giữa các lần truyền dữ liệu.
### Data modes
SPI linh hoạt với data length nó có thể xử lý. Trong 8-bit data tranfer là chung, SPI có thể cấu hình xử lý data length khác nhau, chẳng hạn như 16-bit hoặc 32-bit, phụ thuộc vào ứng dụng. Master và slave chấp nhận data length đảm bảo giao tiếp chính xác.
### SPI speed
Một trong những ưu điểm lớn của SPI là tốc độ cao. SPI có thể hoạt động ở tần số rất cao, thường lên đến vài chục MHz, tùy thuộc vào khả năng phần cứng của cả master và slave.
- **Device capabilities**: Tốc độ tối đa hổ trợ cả 2 master và slave.
- **Signal integrity**: Tốc độ càng cao càng dễ phát sinh các vấn đề như xuyên nhiễu (crosstalk) và phản xạ tín hiệu (reflections), đặc biệt khi đường dây dài.
- **Power consumption**: Tốc độ cao hơn sẽ tiêu thụ nhiều năng lượng hơn, điều này đặc biệt quan trọng với các hệ thống chạy bằng pin.
## The STM32F4 SPI peripheral
### Key features
- **Full-duplex and half-duplex communication**: Hổ trợ đồng thời cả 2 way (full-duplex) hoặc 1 way giao tiếp (half-duplex).
- **Master/slave configuration**: Mỗi SPI peripheral có thể cấu hình hoặc như là một master hoặc một slave device.
- **Flexible data size**: Hỗ trợ data size mức từ 4 tới 16bit.
- **Direct Memory Access (DMA) support**: DMA support data transfer không qua CPU.
- **Negative SS (NSS) pin management**: Hardware management của NSS pin để cấu hình multi-slave.
- **Cyclic Redundancy Check (CRC) support**: Phần cứng tích hợp chức năng tính CRC để kiểm tra và đảm bảo tính toàn vẹn của dữ liệu.
- **Bidirectional mode**: Hỗ trợ giao tiếp hai chiều, cho phép 1 đường data để sử dụng cho cả 2 send và receive.
### Key SPI register
#### SPI Control Register 1 (SPI_CR1)
Nó bao gồm set **SPI mode, data format, clock settings** và các bit control.
- **CPHA**: Bit này xác định cạnh của xung clock mà dữ liệu được lấy mẫu (sample). CPHA = 0 → dữ liệu được lấy ở cạnh đầu tiên (leading edge). CPHA = 1 → dữ liệu được lấy ở cạnh thứ hai (trailing edge).
- **CPOL**: Bit này thiết lập mức logic ở trạng thái idle của đường clock. CPOL = 0 → clock ở mức thấp khi không hoạt động. CPOL = 1 → clock ở mức cao khi không hoạt động.
- **Master Selection (MSTR)**: Bit này cấu hình SPI là master hay slave. MSTR = 1 → SPI ở chế độ master.MSTR = 0 → SPI ở chế độ slave.
- **Baud Rate Control (BR[2:0])**: Các bit này dùng để cấu hình tốc độ baud (tốc độ xung SPI).
- **SPI Enable (SPE)**: Bit này dùng để bật SPI. Phải đặt SPE = 1 thì SPI mới hoạt động.
- **Frame Format (LSBFIRST)**: Bit này xác định thứ tự bit khi truyền dữ liệu. LSBFIRST = 0 → truyền MSB trước (bit có trọng số lớn nhất). LSBFIRST = 1 → truyền LSB trước (bit có trọng số nhỏ nhất).
- **SS Internal (SSI)**: Bit này dùng trong chế độ master để điều khiển nội bộ tín hiệu SS.
- **Software Slave Management (SSM)**: Khi đặt SSM = 1, cho phép quản lý chân SS bằng phần mềm, nghĩa là master tự điều khiển SS thay vì phần cứng tự động.

#### SPI Status Register (SPI_SR)
- **Receive Buffer Not empty (RXNE)**: Cờ này cho biết bộ đệm nhận (receive buffer) đang chứa dữ liệu chưa được đọc.
- **Transmit Buffer Empty (TXE)**: Cờ này báo rằng bộ đệm truyền (transmit buffer) đang rỗng và sẵn sàng nhận dữ liệu mới để gửi đi.
- **CRC Error Flag (CRCERR)**: Cờ này được set khi phát hiện lỗi CRC, cho thấy có khả năng dữ liệu bị lỗi hoặc bị sai lệch.
- **Mode Fault (MODF)**: Cờ này báo lỗi chế độ, thường xảy ra do cấu hình master/slave không đúng (ví dụ có xung NSS không hợp lệ khi đang ở chế độ master).
- **Overrun Flag (OVR)**: Cờ này báo tình trạng tràn dữ liệu, khi dữ liệu nhận được nhưng CPU không đọc kịp, làm dữ liệu mới ghi đè lên dữ liệu cũ.
- **Busy Flag (BSY)**: Cờ này cho biết SPI đang bận, tức là đang trong quá trình truyền hoặc nhận dữ liệu.
#### SPI Data Register (SPI_DR)
- **Transmitting data**: Khi ta ghi dữ liệu vào thanh ghi SPI_DR, dữ liệu đó sẽ được gửi ra ngoài qua đường MOSI.
- **Receiving data**: Khi ta đọc thanh ghi SPI_DR, ta sẽ lấy được dữ liệu đã được nhận vào từ đường MISO.

## Developing the SPI driver
Links code: [SPI Driver](https://github.com/LooOnGit/Bare_Metal_STM/tree/adf7a3da75fafb2a2197813f56859cbae8fdcc4a)
