---
title: "Kernel"
date: 2025-10-11 17:00:25 +0800
categories: [Linux]
tags: [Linux]
---

# ğŸ§ Linux Kernel

## ğŸ“Œ Giá»›i thiá»‡u
Linux Kernel lÃ  nhÃ¢n cá»§a há»‡ Ä‘iá»u hÃ nh Linux, Ä‘Ã³ng vai trÃ² quan trá»ng trong viá»‡c quáº£n lÃ½ tÃ i nguyÃªn há»‡ thá»‘ng vÃ  cung cáº¥p interface giá»¯a pháº§n cá»©ng vÃ  pháº§n má»m.

![alt text](/assets/Linux/Kernel/kernel.png)


## ğŸ§© 1. Native Compile (biÃªn dá»‹ch ná»™i bá»™) vÃ  Cross Compile
### Cross compile
Cross compile nghÄ©a lÃ  biÃªn dá»‹ch mÃ£ nguá»“n trÃªn má»™t há»‡ thá»‘ng (host) Ä‘á»ƒ táº¡o ra chÆ°Æ¡ng trÃ¬nh cháº¡y trÃªn má»™t há»‡ thá»‘ng khÃ¡c (target).

**VÃ­ dá»¥:**
- Báº¡n viáº¿t code trÃªn mÃ¡y tÃ­nh x86 (Windows hoáº·c Linux),
- NhÆ°ng báº¡n muá»‘n chÆ°Æ¡ng trÃ¬nh cháº¡y trÃªn bo máº¡ch ARM (nhÆ° STM32, ESP32, Raspberry Pi, hoáº·c Renesas RZ).

### Native Compile
LÃ  quÃ¡ trÃ¬nh biÃªn dá»‹ch vÃ  cháº¡y chÆ°Æ¡ng trÃ¬nh trÃªn cÃ¹ng má»™t há»‡ thá»‘ng (host = target).

## ğŸ“˜ 2. Kernel Basics

### 2.1 ğŸŒ³ Cáº¥u trÃºc Kernel
1. **Monolithic Kernel**
   - Process Management
   - Memory Management
   - File System
   - Device Drivers
   - Network Stack

2. **Kernel Subsystems**
   - VFS (Virtual File System)
   - Network Stack
   - Block I/O
   - Character Devices
   - IPC (Inter-Process Communication)

### 2.2 ğŸ”„ Process Management
1. **Process Scheduling**
   - CFS (Completely Fair Scheduler)
   - Real-time schedulers
   - Process priorities

2. **Process Creation**
   - fork() vÃ  exec()
   - Copy-on-write
   - Process context

### 2.3 ğŸ’¾ Memory Management
1. **Virtual Memory**
   - Page Tables
   - TLB Management
   - Memory Mapping

2. **Memory Allocators**
   - Buddy Allocator
   - Slab Allocator
   - vmalloc

## ğŸ›  3. Kernel Development

### 3.1 ğŸ”§ Kernel Module Programming
```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

static int __init hello_init(void)
{
    printk(KERN_INFO "Hello, Kernel!\n");
    return 0;
}

static void __exit hello_exit(void)
{
    printk(KERN_INFO "Goodbye, Kernel!\n");
}

module_init(hello_init);
module_exit(hello_exit);
```

### 3.2 ğŸ“± Device Driver Development
1. **Character Drivers**
   - File Operations
   - IOCTL Interface
   - User Space Interface

2. **Block Drivers**
   - Request Queue
   - Bio Layer
   - Block Layer

3. **Platform Drivers**
   - Device Tree
   - Platform Data
   - Resource Management

### 3.3 ğŸ Setup Evironment
1. **Linux kernel header**
    - LÃ  thÃ nh páº§n Ä‘uá»c sá»­ dá»¥ng Ä‘á»ƒ biÃªn dá»‹ch cho module cá»§a kernel.
    - Kernel header Ä‘Æ°á»£c cÃ i Ä‘áº·t pháº£i trÃ¹ng vá»›i kernel version mÃ  báº¡n muá»‘n sá»­ dá»¥ng (uname -r).
    - **CÃº phÃ¡p:**
```bash
    sudo apt install -y linux-headers-`uname-r`
```
    - ÄÆ°á»ng dáº«n: `/lib/modules/`

![alt text](/assets/Linux/Kernel/header_1.png)

TrÃ¬nh tá»± cÃ i Ä‘áº·t kernel header:
```bash
uname -r
sudo apt update
sudo apt install linux-headers-$(uname -r)
```

2. **Init/Exit Funtion**
   - **__init** lÃ  chá»©c nÄƒng Ä‘áº§u tiÃªn Ä‘Æ°á»£c thá»±c thi khi module Ä‘Æ°á»£c load vÃ o kernel.
   - **__exit** lÃ  chá»©c nÄƒngÄ‘Æ°á»£c thá»±c thi sau cÃ¹ng khi module Ä‘Æ°á»£c unload khá»i kernel.

```c
/**
 * @file    hello.c
 * @author  Akshat Sinha
 * @date    10 Sept 2016
 * @version 0.1
 * @brief  An introductory "Hello World!" loadable kernel
 *  module (LKM) that can display a message in the /var/log/kern.log
 *  file when the module is loaded and removed. The module can accept
 *  an argument when it is loaded -- the name, which appears in the
 *  kernel log files.
*/
#include <linux/module.h>     /* Needed by all modules */
#include <linux/kernel.h>     /* Needed for KERN_INFO */
#include <linux/init.h>       /* Needed for the macros */

#define DRIVER_AUTHOR "Loo"
#define DRIVER_DESC   "A simple Hello world LKM!"

/*Constructor*/
static int __init hello_start(void)
{
    printk(KERN_INFO "Loading hello module...\n");
    printk(KERN_INFO "Hello world\n");
    return 0;
}

/*Destructor*/
static void __exit hello_end(void)
{
    printk(KERN_INFO "Goodbye Mr.\n");
}

module_init(hello_start);
module_exit(hello_end);

MODULE_LICENSE("GPL");
MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);

MODULE_VERSION("0.1");
```

**printk**: Giá»‘ng printf thÃ´i.

![alt text](/assets/Linux/Kernel/check_hello_kerne;.png)

Sau khi make rá»“i sáº½ cÃ³ file **.ko* lÃºc nÃ y lÃ m sao Ä‘á»ƒ load chÆ°Æ¡ng trÃ¬nh vÃ o kernel cháº¡y.

![alt text](/assets/Linux/Kernel/load_in_kernel.png)

kiá»ƒm tra sau cháº¡y

![alt text](/assets/Linux/Kernel/check_ko.png)

BÃ¢y giá» muá»‘n xÃ³a module Ä‘Ã³ Ä‘i dÃ¹ng  nhÆ° sau

![alt text](/assets/Linux/Kernel/remove_module.png)

4. **Module information**
    Sá»­ dá»¥ng modinfo Ä‘áº» xem thÃ´ng tin module
    - License: Giáº¥y phÃ©p GPL (Cho phÃ©p dÃ¹ng mÃ£ nguá»“n kernel free).
    - Author: NhÃ  phÃ¡t triá»ƒn module.
    - Module description: MÃ´ táº£ sÆ¡ bá»™ vá» module.
    - Module version: PhiÃªn báº£n module.

![alt text](/assets/Linux/Kernel/infor_kernel.png)

## ğŸ“Š Standard Format Character Device Driver

### 4.1 ğŸ”’ Allocate device number (major/ minor)
   - Application giao tiáº¿p vÃ³i pháº§n cá»©ng nhÆ° tháº¿ nÃ o?
   - Device number
      1. Major number: LÃ  sá»‘ xÃ¡c Ä‘á»‹nh liÃªn káº¿t giá»¯a driver vÃ  device. Má»™t major number cÃ³ thá»ƒ Ä‘Æ°á»£c chia sáº» giá»¯a nhiá»u device driver.
      2. Minor number: LÃ  sá»‘ dg Ä‘á»ƒ phÃ¢n biá»‡t cÃ¡c thiáº¿t bá»‹ váº­t lÃ½ riÃªng láº».
   - Äá»ƒ cáº¥p phÃ¡t device number ta cÃ³ thá»ƒ sá»­ dá»¥ng má»™t trong hai cÃ¡ch:
      1. Static allocating
      2. Dynamic allocating

- CÃ¡ch Ä‘Äƒng kÃ­ **device number**:
```c
    /* 1. Allocating device number (cat /pro/devices)*/
    if (alloc_chrdev_region(&mdev.dev_num, 0, 1, "m-cdev") < 0) {
	    pr_err("Failed to alloc chrdev region\n");
	    return -1;
    }
    pr_info("Major = %d Minor = %d\n", MAJOR(mdev.dev_num), MINOR(mdev.dev_num));
```

- HÃ m exit:
```c
unregister_chrdev_region(mdev.dev_num, 1);      /* 01 */
```

   - Device file náº±m trong thÆ° má»¥c
```bash
ls -l /dev/
```

![alt text](/assets/Linux/Kernel/start.png)

**VÃ­ dá»¥:** cÃ³ chÆ°Æ¡ng trÃ¬nh blink led vÃ­ dá»¥ trÃªn beaglebone. Äáº§u tiÃªn application Ä‘á»c ghi vÃ o trong **Device File** (giá»‘ng chÃ¢n Ä‘iá»u khiá»ƒn led). VÃ­ dá»¥ **Device File** /dev/ttyS0 lÃ  1 device file Ä‘i, thÃ¬ nÃ³ Ä‘Æ°á»£c gÃ¡n báº±ng 1 device number thÃ¬ nÃ³ sáº½ tham chiáº¿u Ä‘áº¿n **device number** (major vÃ  minor) tÆ°Æ¡ng á»©ng vá»›i **hardware** tá»« 2 sá»‘ Ä‘Ã³ sáº½ tÃ¬m Ä‘Ãºng **Device Driver**.

### 4.2 âš¡ Create Device File
Äá»ƒ táº¡o ra **device file** thÃ¬ pháº£i táº¡o **Class device** vÃ  **device file**.

Äá»‘i vá»›i **Class Device** cÃ³ create vÃ  destroy:
```c
    /* 02. Creating struct class */
    if ((mdev.m_class = class_create(THIS_MODULE, "m_class")) == NULL) {
        pr_err("Cannot create the struct class for my device\n");
        goto rm_device_numb;
    }

   rm_device_numb:
    unregister_chrdev_region(mdev.dev_num, 1);
```
Äá»‘i vá»›i **device file** cÃ³ create vÃ  destroy:

```c
    /* 03. Creating device*/
    if ((device_create(mdev.m_class, NULL, mdev.dev_num, NULL, "m_device")) == NULL) {
        pr_err("Cannot create my device\n");
        goto rm_class;
    }

    rm_class:
    class_destroy(mdev.m_class);
```

HÃ m **Exit**:
```c
__exit hello_world_exit(void)   /* Destructor */
{
    device_destroy(mdev.m_class, mdev.dev_num);     /* 03 */
    class_destroy(mdev.m_class);                    /* 02 */
    unregister_chrdev_region(mdev.dev_num, 1);      /* 01 */

    pr_info("Goodbye\n");
}
```

Äá»ƒ kiá»ƒm tráº£ **device file**:
```bash
ls -l /dev/ | grep 243
```

### 4.3 ğŸŒ Register File operations
   - Struct **inode** lÃ  stuct chá»©a toÃ n bá»™ thÃ´ng tin cá»§a má»™t file.
   - LÆ°u Ã½ khÃ¡c biá»‡t giá»¯a open file vÃ  file.

ÄÃ¢y lÃ  1 struct **inode** vÃ­ dá»¥:

![alt text](/assets/Linux/Kernel/struct_inode.png)

ÄÃ¢y lÃ  vÃ­ dá»¥ struct **cdev**:

![alt text](/assets/Linux/Kernel/struct_cdev.png)

Struct **cdev** lÃ  má»™t pháº§n tá»­ cá»§a struct **inode**. LÃ  struct Ä‘áº¡i diá»‡n cho character **device**.

Struct **file_openrations** lÃ  má»™t pháº§n tá»§ cá»§a struct **cdev**. Äá»‹nh nghÄ©a toÃ n bá»™ cÃ¡c hoáº¡t Ä‘á»™ng cá»§a file nhÆ° (open, read, write, close, mmap, ioctl).

![alt text](/assets/Linux/Kernel/struct_file_openration.png)

