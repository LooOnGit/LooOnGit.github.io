---
title: "Pipe"
date: 2025-10-05 08:46:25 +0800
categories: [Linux]
tags: [Linux]
---


Pipe có ngưỡng gọi là Pipe_buf = 4096 nhỏ hơn thì gọi là đảm bảo tính nguyên tử khi tiến trình khác ghi vào hết rồi mới đến trình này ghi vào để không bị trộn dữ liệu. Khi lớn hơn thì chia nhỏ nhiều dữ liệu vào pipe nên không chắc có thể bị trộn lẫn với process khác.

Kiểm tra **pipe_buf**
```bash
getconf PIPE_BUF /tmp
```

##
### Hàm tạo pipe
```c
int pipe(int filedes[2])
```
khi gọi này sẽ tạo buffer dưới kernel.

**VD:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define BUFFER_SIZE 128

int main()
{
    int pipefd[2]; // pipefd[0] is read end, pipefd[1] is write end
    char write_msg[] = "Hello from the write end";
    char read_buffer[BUFFER_SIZE];
    size_t bytes_read;

    //Create the pipe
    if(pipe(pipefd) == -1){
        error("pipe");
        exit(EXIT_FAILURE);
    }

    //write a message to the pipe
    write(pipefd[1], write_msg, strlen(write_msg));
    printf("[Writer] Wrote to pipe: %s\n", write_msg);

    //close the write end to simulate end-of-input
    close(pipefd[1]);

    //read the message frome the pipe
    bytes_read = read(pipefd[0], read_buffer, sizeof(read_buffer) - 1);
    if(bytes_read == -1)
    {
        perror("read");
        exit(EXIT_FAILURE);
    }

    //Null-terminal the striong and print it
    read_buffer[bytes_read] = "\0";
    printf("[Reader] Read from pipe: %s\n", read_buffer);

    //Read the message from the pipe and get EOF because the write End has been cloesed
    bytes_read = read(pipefd[0], read_buffer, sizeof(read_buffer)-1);
    if(bytes_read == -1)
    {
        perror("read");
        exit(EXIT_FAILURE);
    }

    if(bytes_read == 0){
        printf("EOF Every write End closed!\n");
        //closed the read end
        close(pipefd[0]);
    }
    return 0;
}
```

![alt text](/assets/Linux/Pipe/fork.png)

Theo hình trên thì nên cha ghi con đọc, hoặc cha đọc con ghi thì được. Không nên cả 2 ghi và đọc như hình.

![alt text](/assets/Linux/Pipe/fork2.png)

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

#define BUFFER_SIZE 128

int main() {
    int pipefd[2]; // pipefd[0] is read end, pipefd[1] is write end
    pid_t pid;
    char buffer[BUFFER_SIZE];

    // Create the pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // Create a child process
    pid = fork();

    if (pid < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Child process: read from pipe
        close(pipefd[1]); // Close unused write end

        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer) - 1);
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0'; // Null-terminate the string
            printf("[Child] Received from parent: %s\n", buffer);
        } else {
            perror("read");
        }

        close(pipefd[0]); // Close read end
        exit(EXIT_SUCCESS);
    } else {
        // Parent process: write to pipe
        close(pipefd[0]); // Close unused read end

        printf("[Parent] Enter a message: ");
        fgets(buffer, sizeof(buffer), stdin); // Read input from keyboard

        // Remove newline character if present
        buffer[strcspn(buffer, "\n")] = '\0';

        write(pipefd[1], buffer, strlen(buffer));
        close(pipefd[1]); // Close write end after writing

        wait(NULL); // Wait for child to finish
    }

    return 0;
}
```

Không dùng pipe thông thương để giao tiếp giữa 2 `Process` được. Không dùng đến **pipe** dùng đến **FiFo**, ví dụ giữa server và client.

### Tạo FiFo
```bash
int mkfifo(const char *pathname, mode_t mode);
```
Mở FiFo để đọc: `open()` với **O_RDONLY**
Mở FiFo để ghi: `open()` vói **O_WRONLY**