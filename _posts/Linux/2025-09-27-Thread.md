---
title: "Thread"
date: 2025-09-27 15:58:20 +0800
categories: [Linux]
tags: [Linux]
---

# Thread Trong Linux

## üéØGi·ªõi thi·ªáu
### Thread l√† g√¨?
Thread l√† ƒë∆°n v·ªã nh·ªè ƒë∆∞·ª£c ch·∫°y trong PID (Process ID), coi nh∆∞ l√† th√†nh ph·∫ßn con c·ªßa Process.

## üõ†Ô∏èSo s√°nh Process v√† Thread
Memory layout c·ªßa 1 **Process**, c·ª© 1 **Process** s·∫Ω ƒë∆∞·ª£c c·∫•p v√πng nh·ªõ v·ªõi m·ªói process s·∫Ω c√≥ layout nh∆∞ d∆∞·ªõi ƒë√¢y.
![alt text](/assets/Linux/Thread/memory_layoutProcess.png)

Th√¨ c√°c **Thread** s·∫Ω n·∫±m trong memory layout c·ªßa 1 **Process** nh∆∞ d∆∞·ªõi ƒë√¢y.
![alt text](/assets/Linux/Thread/memory_layout.png)

M·ªói thread s·∫Ω ƒë∆∞·ª£c c·∫•p cho ph√¢n v√πng tr√™n **Stack**. C≈©ng c√≥ th·ªÉ truy c·∫≠p ƒëu·ªçc c√°c bi·∫øn local c·ªßa t·ª´ng *Thread*, th√¨ c√≥ th·ªÉ chia s·∫Ω ƒë∆∞·ª£c t·∫°i v·ªã n·∫±m chung tr√™n Ram v√† c√≥ th·ªÉ d√πng ƒë·ªãa ch·ªâ ƒë·ªÉ truy c·∫≠p t·ªõi.

**L∆∞u √Ω**: 
- Khi **Thread** n√†y mu·ªën truy c·∫≠p bi·∫øn local c·ªßa **Thread** k√¨a th√¨ c·∫ßn th·∫≠n v√≤ng ƒë·ªùi c·ªßa bi·∫øn local ƒë√≥. Nh∆∞ng ph·∫£i c√πng trong **Process**.

## üíªHo·∫°t ƒë·ªông v·ªõi Thread
D√πng Thread n√™n khai b·∫£o th∆∞ vi·ªán `pthread.h`
Khi c√°c thread ƒë∆∞·ª£c t·∫°o trong **Procees** ƒë·ªÅu c√≥ thread_ID.
Ki·ªÉu d·ªØ li·ªáu c·ªßa *Thread* l√† ``pThread_t`.
Khi mu·ªën l·∫•y ID Thread d√πng:
```c
pthread_self()
```
Mu·ªën so s√°nh 2 thread ID c√≥ gi·ªëng nhau kh√¥ng
```c
pthread_equal(pthread_t t1, pthread_t t2);
```
T·∫°o **Thread**
```c
int pthread_create(pthread_t *thread, 
                   const pthread_attr_t *attr,
                   void *(*start_routine)(void *), 
                   void *arg);
```
- `thread`: bi·∫øn ki·ªÉu pthread_t ƒë·ªÉ l∆∞u ID c·ªßa thread m·ªõi.
- `attr`: thu·ªôc t√≠nh c·ªßa thread (ƒë·ªÉ NULL n·∫øu d√πng m·∫∑c ƒë·ªãnh).
- `start_routine`: h√†m m√† thread s·∫Ω th·ª±c thi (ph·∫£i c√≥ d·∫°ng void* function(void *arg)).
- `arg`: tham s·ªë truy·ªÅn v√†o h√†m (ki·ªÉu void*, c√≥ th·ªÉ √©p ki·ªÉu).
- Tr·∫£ v·ªÅ 0 n·∫øu th√†nh c√¥ng, kh√°c 0 n·∫øu l·ªói.


D∆∞·ªõi ƒë√¢y l√† ƒëo·∫°n code m·∫´u:
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>

typedef struct data_name{
    char first[10];
    char last[10];
} data_name;


void* print_number(void* arg){
    int *num = (int*)arg;
    pthread_t tid = pthread_self();
    printf("I'm number : %d, thread ID: %lu\n", *num, (unsigned long)tid);
    return NULL;
}

//Thread function that prints the number and thread ID
void* print_name(void* arg){
    data_name *name = (data_name*)arg;
    pthread_t tid = pthread_self();
    printf("I'm %s %s, thread ID %lu\n", name->first, name->last, (unsigned long)tid);
    return NULL;
}

int main()
{
    pthread_t threads_name;
    pthread_t threads_number;

    int number = 10;

    data_name name;
    strcpy(name.first, "Loo");
    strcpy(name.last, "Dev");

    //Create threads to print number
    pthread_create(&threads_number, NULL, print_number, &number);

    //Create threads to print name
    pthread_create(&threads_name, NULL, print_name, &name);

    //wait for threads to finish (better than sleep)
    pthread_join(threads_number, NULL);
    pthread_join(threads_name, NULL);

    return 0;
}
```

K·∫øt qu·∫£:

```c
I'm Loo Dev, thread ID 3060180064
I'm number : 10, thread ID: 3068572768
```

K·∫øt th√∫c 1 **Thread*:
- C√°ch 1 `return`
- G·ªçi h√†m `pthread_exit()`
**V√≠ d·ª•**:
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h> // sleep()

void* worker(void* arg) {
    int id = *((int*)arg);
    printf("Thread %d dang lam viec...\n", id);
    sleep(1);

    // K·∫øt th√∫c thread v√† tr·∫£ v·ªÅ gi√° tr·ªã
    int *result = malloc(sizeof(int)); // c·∫•p ph√°t v√πng nh·ªõ cho k·∫øt qu·∫£
    *result = id * 10; // gi·∫£ s·ª≠ k·∫øt qu·∫£ = id * 10
    pthread_exit((void*)result);
}

int main() {
    pthread_t t1, t2;
    int id1 = 1, id2 = 2;
    int *res1, *res2;

    // T·∫°o 2 thread
    pthread_create(&t1, NULL, worker, &id1);
    pthread_create(&t2, NULL, worker, &id2);

    // Ch·ªù thread 1 v√† l·∫•y k·∫øt qu·∫£
    pthread_join(t1, (void**)&res1);
    printf("Thread 1 tra ve: %d\n", *res1);
    free(res1); // gi·∫£i ph√≥ng b·ªô nh·ªõ

    // Ch·ªù thread 2 v√† l·∫•y k·∫øt qu·∫£
    pthread_join(t2, (void**)&res2);
    printf("Thread 2 tra ve: %d\n", *res2);
    free(res2);

    printf("Main ket thuc\n");
    return 0;
}
```
Khi **Thread** con exit ho·∫∑c return m√† **Thread** cha kh√¥ng h·ª©ng tr·∫£ v·ªÅ ƒë√≥ th√¨ g·ªçi l√† **Zombie Thread**. Khi k·∫øt th√∫c th∆∞c thi m√† v·∫´n c√≤n t·ªìn t·∫°i trong h·ªá th·ªëng.
**V√≠ d·ª• zombie Thread:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

void* worker(void* arg) {
    printf("Thread dang lam viec...\n");
    sleep(1);
    printf("Thread ket thuc!\n");
    pthread_exit(NULL);
}

int main() {
    pthread_t tid;

    // T·∫°o thread
    pthread_create(&tid, NULL, worker, NULL);

    // Main kh√¥ng join thread -> thread s·∫Ω tr·ªü th√†nh zombie sau khi k·∫øt th√∫c
    printf("Main ket thuc ma khong join!\n");
    sleep(5); // gi·ªØ ch∆∞∆°ng tr√¨nh ch·∫°y ƒë·ªÉ xem zombie t·ªìn t·∫°i

    return 0;
}
```

## üìäQu·∫£n l√Ω Thread 
G·ªçi h√†m `pthread_join` truy·ªÅn v√†o thread ID g·ªçi ra ƒë·ªÉ gi·∫£i th·ªëng t√†i nguy√™n **Thread** ƒë√≥. G·ªçi ra th√¨ ngay ch·ªó n√†y ƒë·ª©ng ƒë·ª£i, n√™n hay ƒë·ªÉ d∆∞·ªõi. N√™n c√≥ c√°ch kh√°c l√† **pthreaddetack()**.

**V√≠ d·ª•**:
```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void* worker(void* arg) {
    // Thread t·ª± detach b·∫£n th√¢n
    pthread_detach(pthread_self());

    printf("Thread bat dau lam viec...\n");
    sleep(2);
    printf("Thread ket thuc (tu detach, khong can join)!\n");

    pthread_exit(NULL);
}

int main() {
    pthread_t tid;

    pthread_create(&tid, NULL, worker, NULL);

    printf("Main tao thread va khong join\n");
    sleep(5); // cho worker chay xong

    printf("Main ket thuc\n");
    return 0;
}

```
- `pthread_detach(tid);` b√°o cho h·ªá ƒëi·ªÅu h√†nh r·∫±ng thread n√†y kh√¥ng c·∫ßn join n·ªØa.
- Khi thread k·∫øt th√∫c ‚Üí kernel t·ª± ƒë·ªông gi·∫£i ph√≥ng t√†i nguy√™n. Nh·ªù v·∫≠y kh√¥ng c√≤n zombie thread.

## ‚öôÔ∏èƒê·ªìng b·ªô Thread
### Atomic/non-Atomic
ƒê·∫£m b·∫£o cho chu·ªói c√¥ng vi·ªác th·ª±c ·ªán kh√¥ng ·∫£nh ∆∞·ªüng ƒë·∫øn c√¥ng vi·ªác kh√°c.
**V√≠ d·ª•**:
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define MAX_NUMBER 1000

FILE *file;
int local = 0;

void* thread_func(void* arg) {
    int thread_id = *(int*)arg;
    while (1) {
        if (local > MAX_NUMBER) break;
        local++; // kh√¥ng ƒë∆∞·ª£c b·∫£o v·ªá -> race condition
        usleep(5000); // sleep 5ms
        fprintf(file, "Thread %d: %d\n", thread_id, local);
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    int id1 = 1, id2 = 2;

    file = fopen("output_unsync.txt", "w");
    if (!file) {
        perror("Cannot open file");
        return 1;
    }

    pthread_create(&t1, NULL, thread_func, &id1);
    pthread_create(&t2, NULL, thread_func, &id2);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    fclose(file);
    return 0;
}

```                                                                        K·∫øt qu·∫£:
```bash
Thread 1: 2
Thread 2: 2
Thread 1: 4
Thread 2: 5
Thread 1: 6
Thread 2: 7
Thread 1: 8
Thread 2: 9
Thread 1: 10
Thread 2: 11
Thread 1: 12
Thread 2: 13
Thread 1: 14
Thread 2: 15
Thread 1: 16
Thread 2: 17
Thread 1: 18
Thread 2: 19
Thread 1: 20
Thread 2: 21
```
ƒê√°ng l√≠ ra th√¨ ph·∫£i ch·∫°y 2 3 4 5 nh∆∞ng trong n√†y ch·∫°y c√≥ l√∫c ƒë√∫ng c√≥ l√∫c 2 2 ƒë√≥ th·∫•y kh√¥ng.
### Critical Section

### Shared Resource

## üîíThread Sync - Mutex Lock
![alt text](/assets/Linux/Thread/mutex.png)

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define MAX_NUMBER 20

FILE *file;
int local = 0;
pthread_mutex_t lock;  // khai b√°o mutex

void* thread_func(void* arg) {
    int thread_id = *(int*)arg;
    while (1) {
        // kh√≥a tr∆∞·ªõc khi v√†o critical section
        pthread_mutex_lock(&lock);

        if (local > MAX_NUMBER) {
            pthread_mutex_unlock(&lock); // m·ªü kh√≥a tr∆∞·ªõc khi tho√°t
            break;
        }

        local++; // v√πng d·ªØ li·ªáu chia s·∫ª ƒë∆∞·ª£c b·∫£o v·ªá
        fprintf(file, "Thread %d: %d\n", thread_id, local);

        pthread_mutex_unlock(&lock); // m·ªü kh√≥a sau khi xong

        usleep(5000); // sleep 5ms cho d·ªÖ th·∫•y l·ªói n·∫øu c√≥
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    int id1 = 1, id2 = 2;

    file = fopen("output_sync.txt", "w");
    if (!file) {
        perror("Cannot open file");
        return 1;
    }

    // kh·ªüi t·∫°o mutex
    pthread_mutex_init(&lock, NULL);

    pthread_create(&t1, NULL, thread_func, &id1);
    pthread_create(&t2, NULL, thread_func, &id2);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    // h·ªßy mutex
    pthread_mutex_destroy(&lock);

    fclose(file);
    return 0;
}
```

**L∆∞u √ù:** Khi vi·∫øt qu√° nhi·ªÅu **thread** th√¨ 1 **thread** ch·∫°y 9 **thread** ƒë·ª£i ƒë·∫øn khi tr·∫£ thread kh√¥ng bi·∫øt n√†o ch·∫°y tr∆∞·ªõc nh√©.

### Deadlock
![alt text](/assets/Linux/Thread/deablock.png)

X·∫£y ra t√¨nh tr·∫°ng 2 √¥ng ƒë·ª©ng ƒë·ª£i nhau nh·∫£ mutex nh∆∞ng kh√¥ng c√≥ ai nh·∫£, th√¨ c·ª© ƒë·ª£i ch√©o nhau ƒë√≥ l√† **Deadlock**.

N√™n thi·∫øt k·∫ø code theo ƒë√∫ng th·ª© t·ª± lock. ƒê·ªÉ tr√°nh deadlock c√≥ th·ªÉ d√πng `pthread_mutex_trylock` c·ª© v√†i gi√¢y ra ki·ªÉm tra lock. 

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond   = PTHREAD_COND_INITIALIZER;

int brick_ready = 0;

void* producer(void* arg) {
    printf("Producer: making bricks...\n");
    sleep(3); // gi·∫£ l·∫≠p th·ªùi gian s·∫£n xu·∫•t g·∫°ch

    pthread_mutex_lock(&mutex);
    brick_ready = 1;
    printf("Producer: Bricks are ready!\n");

    pthread_cond_signal(&cond); // b√°o cho consumer
    pthread_mutex_unlock(&mutex);

    return NULL;
}

void* consumer(void* arg) {
    pthread_mutex_lock(&mutex);
    while (!brick_ready) {
        printf("Consumer: Waiting for bricks...\n");
        pthread_cond_wait(&cond, &mutex);
        // khi ƒë∆∞·ª£c ƒë√°nh th·ª©c, mutex s·∫Ω ƒë∆∞·ª£c lock l·∫°i
    }

    printf("Consumer: Got the bricks, do my work!!!\n");
    pthread_mutex_unlock(&mutex);

    printf("Consumer: Done my work!\n");
    return NULL;
}

int main() {
    pthread_t prod, cons;

    pthread_create(&cons, NULL, consumer, NULL);
    pthread_create(&prod, NULL, producer, NULL);

    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    return 0;
}
```
## üöÄThread Sync - Conditional Variable
`pthread_cond_wait`, `pthread_cond_signal`, `pthread_cond_broadcast`.