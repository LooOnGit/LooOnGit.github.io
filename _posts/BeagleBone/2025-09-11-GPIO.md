---
title: "GPIO"
date: 2025-11-09 12:28:25 +0700
categories: [BeagleBone]
tags: [BeagleBone]
---

# üêß GPIO

[PIN_OUT](https://vadl.github.io/beagleboneblack/2016/07/29/setting-up-bbb-gpio)

## Kernel l√†m vi·ªác v·ªõi GPIO
![alt text](/assets/BeagleBone/GPIO/image_1.png)

Kh√¥ng th·ªÉ ghi tr·ª±c ti·∫øp v√†o **address physiscal** m√† ph·∫£i th√¥ng qua kernel address space c√≥ h√†m `remap`.


L∆∞u √Ω ƒëi·ªÅu n√†y 1 word c·ªßa 1 chip 32bit b·∫±ng 4byte, cho n√™n:
**V√≠ d·ª•:**
```c
(0x00 + 1) = 0x04 
```
B·ªüi v√¨ 1 l·∫ßn nh·∫£y l√† `4byte` n√™n c·∫ßn tr·ªçng c√≥ d√πng `offset/4`.

## Code Led ch·ªõp t·∫Øt
file.h
```c
// gpio.h
#ifndef __LED_MODULE_H__
#define __LED_MODULE_H__

#define GPIO0_ADDR_BASE     0x44E07000
#define GPIO0_ADDR_END      0x44E07FFF
#define GPIO0_ADDR_SIZE     (GPIO0_ADDR_END - GPIO0_ADDR_BASE)

#define GPIO_OE_OFFSET			    0x134
#define GPIO_CLEARDATAOUT_OFFSET	0x190
#define GPIO_SETDATAOUT_OFFSET		0x194

#define GPIO0_30                    (1 << 30)       /* P9_11 */

#endif  /* __LED_MODULE_H__ */
```
file.c
```c
#include <linux/module.h>   /* This module defines functions such as module_init/module_exit */
#include <linux/io.h>       /* This module defines functions such as ioremap/iounmap */
#include "gpio.h"           /* Gpio modules */

#define DRIVER_AUTHOR "Loo"
#define DRIVER_DESC   "Turn on and off led"

uint32_t __iomem *gpio0_base_addr;

/* Constructor */
static int __init gpio_init(void)
{
    gpio0_base_addr = ioremap(GPIO0_ADDR_BASE, GPIO0_ADDR_SIZE);
    if(!gpio0_base_addr)
        return -ENOMEM;
    
    /* Set gpio0_30 as output mode and turn on */
    *(gpio0_base_addr + GPIO_OE_OFFSET / 4) &= ~GPIO0_30;
    *(gpio0_base_addr + GPIO_SETDATAOUT_OFFSET / 4) |= GPIO0_30;

    pr_info("Hello! Initizliaze successfully!\n");
    return 0;
}

/* Destructor */
static void __exit gpio_exit(void)
{
    *(gpio0_base_addr + GPIO_CLEARDATAOUT_OFFSET / 4) |= GPIO0_30;
    iounmap(gpio0_base_addr);

    pr_info("Good bye my fen !!!\n");
}

module_init(gpio_init);
module_exit(gpio_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC); 
MODULE_VERSION("1.0"); 
```
Makefile(Makefile vi·∫øt hoa ch·ªØ ƒë·∫ßu nh√©)
```make
TOOLCHAIN := /home/looonlinux/word/bbb/kernelbuildscripts/dl/gcc-8.5.0-nolibc/arm-linux-gnueabi/bin/arm-linux-gnueabi-
BBB_KERNEL := /home/looonlinux/word/bbb/kernelbuildscripts/KERNEL

EXTRA_CFLAGS=-Wall
obj-m := gpio.o

all:
	make ARCH=arm CROSS_COMPILE=$(TOOLCHAIN) -C $(BBB_KERNEL) M=$(shell pwd) modules
	
clean:
	make -C $(BBB_KERNEL) M=$(shell pwd) clean
```
### Run v√† deploy l√™n board
![alt text](/assets/BeagleBone/GPIO/make.png)

Scp ch·∫°y tr√™n board

![alt text](/assets/BeagleBone/GPIO/scp.png)

Hai l·ªánh insmod v√† rmmod l√† c√°c l·ªánh d√πng ƒë·ªÉ qu·∫£n l√Ω module nh√¢n (kernel module) trong Linux üß†.

![alt text](/assets/BeagleBone/GPIO/run.png)

## API GPIO Subsystem

### Interger based
- Ph∆∞∆°ng ph√°p s·ª≠ d·ª•ng s·ªë nguy√™n ƒëi·ªÅu khi·ªÉn GPIO.

### C√°ch d√πng
```c
#define GPIO0_30            30

#define LOW                 0
#define HIGH                1

#define DRIVER_AUTHOR "phonglt15 p.linuxfromscratch@gmail.com"
#define DRIVER_DESC   "gpio subsystem"

/* Constructor */
static int __init gpio_init(void)
{
    gpio_request(GPIO0_30, "gpio0_30");
    gpio_direction_output(GPIO0_30, LOW);
    gpio_set_value(GPIO0_30, HIGH);

    pr_info("Hello! gpio status: %d!\n", gpio_get_value(GPIO0_30));
    return 0;
}

/* Destructor */
static void __exit gpio_exit(void)
{
    gpio_set_value(GPIO0_30, LOW);
    gpio_free(GPIO0_30);
    pr_info("Good bye my fen !!!\n");
}
```
`gpio_request(GPIO0_30, "gpio0_30")`

Y√™u c·∫ßu quy·ªÅn s·ª≠ d·ª•ng s·ªë GPIO GPIO0_30 t·ª´ subsystem GPIO. Ph·∫£i set gpio ƒë·ªÉ tr√°nh tr∆∞·ªùng h·ª£p 1 ch√¢n c√≥ nhi·ªÅu ch·ª©c nƒÉng. 

`gpio_direction_output(GPIO0_30, LOW)`

Thi·∫øt l·∫≠p h∆∞·ªõng c·ªßa ch√¢n GPIO l√† output v√† ƒë·∫∑t gi√° tr·ªã ban ƒë·∫ßu b·∫±ng LOW (·ªü ƒë√¢y LOW = 0).

`gpio_set_value(GPIO0_30, HIGH)`

Ghi m·ª©c logic HIGH (1) l√™n ch√¢n GPIO ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh output. ·ªû v√≠ d·ª• n√†y code set HIGH ngay sau khi direction_output ƒë·∫∑t LOW ‚Äî th·ª© t·ª± n√†y nghƒ©a l√† ban ƒë·∫ßu direction set LOW, r·ªìi l·∫≠p t·ª©c set HIGH; c√≥ th·ªÉ g·ªôp ho·∫∑c tu·ª≥ m·ª•c ƒë√≠ch.

`gpio_free` tr·∫£ l·∫°i resource cho kernel, tr√°nh r√≤ r·ªâ t√†i nguy√™n ho·∫∑c xung ƒë·ªôt s·ªë GPIO.

### Descriptor based
- Ph∆∞∆°ng ph√°p ƒëi·ªÅu khi·ªÉn b·∫±ng device tree.
## SYSFS (SYSTEM FILE SYSTEM)
Trong folder sys n√†y ch∆∞a c√°c th√†nh ph·∫ßn nh∆∞ b√™n d∆∞·ªõi.
```bash
root@arm:/# ls /sys/
block  bus  class  dev  devices  firmware  fs  kernel  module  power
```
### Device driver
```bash
root@arm:/# ls /sys/class/
ata_device  bdi          devfreq         extcon    hidraw       input  mdio_bus  mtd           pps        remoteproc   scsi_disk   spi_slave  tty  vc
ata_link    block        dma             firmware  hwmon        iommu  mem       net           ptp        rfkill       scsi_host   thermal    ubi  vtconsole
ata_port    bsg          drm             gpio      i2c-adapter  leds   misc      phy           pwm        rtc          sound       tpm        udc  wakeup
backlight   devcoredump  drm_dp_aux_dev  graphics  i2c-dev      mbox   mmc_host  power_supply  regulator  scsi_device  spi_master  tpmrm      uio  watchdog
```
Khi c√°i n√†y ra ƒë·ªùi s·∫Ω c·ªë g·∫Øng tr·ª´u t∆∞·ª£ng h√≥a c√°c device. 
B√¢y gi·ªù c·∫ßn ƒëi·ªÅu khi·ªÉn 1 led ·ªü ch√¢n n√†o ƒëi.
```bash
root@arm:/sys/class# cd gpio
root@arm:/sys/class/gpio# ls
export  gpio12  gpio13  gpiochip0  gpiochip32  gpiochip64  gpiochip96  unexport
root@arm:/sys/class/gpio# ls
export  gpio12  gpio13  gpiochip0  gpiochip32  gpiochip64  gpiochip96  unexport
root@arm:/sys/class/gpio# cd gpiochip0
root@arm:/sys/class/gpio/gpiochip0# ls
base  device  label  ngpio  power  subsystem  uevent
root@arm:/sys/class/gpio/gpiochip0# cd ..
root@arm:/sys/class/gpio# cd gpiochip0
root@arm:/sys/class/gpio/gpiochip0# ls
base  device  label  ngpio  power  subsystem  uevent
root@arm:/sys/class/gpio/gpiochip0# cat label
gpio-0-31
```
ƒê·ªÉ ghi v√†o th√¨ d√πng `echo`, ƒë·ªçc ra th√¨ `cat`.

C√°c b∆∞·ªõc ƒëi·ªÅu khi·ªÉn ch√¢n GPIO **v√≠ d·ª•** ch√¢n 31.
**1. Export ch√¢n GPIO.**
K√≠ch ho·∫°t ch√¢n GPIO ƒë·ªÉ h·ªá th·ªëng c√≥ th·ªÉ s·ª≠ d·ª•ng:
```bash
echo 31 > /sys/class/gpio/export
```
**2. Set the pin direction (input or output)**
**V√≠ d·ª•:** ƒë·∫∑t l√†m ch√¢n xu·∫•t (output):
```bash
echo out > /sys/class/gpio/gpio31/direction
```
ho·∫∑c input:
```bash
echo in > /sys/class/gpio/gpio31/direction
```
**3. If an output pin, set the level to low or high**
- M·ª©c th·∫•p (0V):
```bash
echo 0 > /sys/class/gpio/gpio31/value
```
- M·ª©c cao (3.3V ho·∫∑c 5V t√πy h·ªá th·ªëng):
```bash
echo 1 > /sys/class/gpio/gpio31/value
```
**4. If an input pin, read the pin's level (low or high)**
```bash
cat /sys/class/gpio/gpio31/value
```
K·∫øt qu·∫£ s·∫Ω l√† 0 ho·∫∑c 1.
**5. When done, unexport the pin**
Gi·∫£i ph√≥ng ch√¢n ƒë·ªÉ h·ªá th·ªëng kh√¥ng c√≤n s·ª≠ d·ª•ng:
```bash
echo 31 > /sys/class/gpio/unexport
```

D√πng c√°ch n√†y ƒë·ªÉ tracking ƒë∆∞·ª£c tr·∫°ng th√°i 1 ch√¢n ch·∫≥ng h·∫°n ki·ªÉu v·∫≠y xem c√≥ connect ch∆∞a.

## Device tree 
Convert h·∫øt c√°c ƒë·ªãa ch·ªâ thanh ghi th√†nh device tree ki·ªÉu v·∫≠y. Cho n√™n khi thay ƒë·ªïi ph·∫ßn c·ª©ng th√¨ subsystem g·ªçi nh∆∞ c≈©, subsystem l·ªõp n√†y t·ª± ƒë·∫øn device tree ƒë·ªÉ bi·∫øt thao t√°c tr√™n ƒë·ªãa ch·ªâ n√†o thanh ghi n√†o.


H√¨nh dung gi·ªëng nh∆∞ √¥ng th·ª£ s·ªØa √¥ng n∆∞·ªõc ƒë·∫øn nh√† ch·ªâ c·∫ßn c·∫ßm theo h·ªôp ƒë·ªì ngh·ªÅ th√¨ h·ªôp ƒë·ªì ngh·ªÅ ƒë√≥ l√† **subsystem** c√≤n b·∫£n v·∫Ω nh√† gi·ªëng b·∫£ng datasheet c√≥ m·∫•y thanh ghi v·∫≠y.

ƒê·∫ßu ti√™n c√≥ l√† `.dts` -> `.dtc` -> `.dtb`
- **s**: source
- **c**: compiler
- **dtb**: binary h·ªá th·ªëng s·∫Ω ƒë·ªçc file n√†y xem th·∫±ng n√†o ƒë√£ ƒë∆∞·ª£c d√πng c√°i n√†o kh√¥ng.

C√≥ th·ªÉ xem `.dts` ƒë·ªÉ vi·∫øt driver.
