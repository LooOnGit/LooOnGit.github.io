---
title: "SYSFS"
date: 2025-11-22 19:28:25 +0800
categories: [BeagleBone]
tags: [BeagleBone]
---

# üêß SYSFS

## T·∫°o to√†n b·ªô c√°c thu·ªôc t√≠nh m√† chung c·∫ßn d√πng
- Direction
- Value
- Export
- Unport
T·∫°o theo group. T·∫•t c·∫£ ƒë·ªëi t∆∞·ª£ng trong linux ƒë·ªÅu ƒë∆∞·ª£c qu·∫£n l√Ω b·ªüi struct.
```c
root@arm:/sys# ls
block  bus  class  dev  devices  firmware  fs  kernel  module  power
root@arm:/sys#
```
v√≠ d·ª• ·ªü ƒë√¢y nh∆∞ block, bus, class, .... T·∫•t c·∫£ c√°c object n√†y ƒë∆∞·ª£c ƒë·∫°i di·ªán b·∫±ng struct `kobject` l√† kernel object.

**VD**:
```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/cdev.h>
#include <linux/device.h>

#define DRIVER_AUTHOR "tranconghoa24@gmail.com"
#define DRIVER_DESC "A simple sysfs character device example"

struct m_foo_dev {
    struct kobject *kobj_ref;
}mdev;

/************ Function Prototypes ***********/
static int __init hello_world_init(void);
static void __exit hello_world_exit(void);

/************ Sysfs Function ****************/
static ssize_t sysfs_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);
static ssize_t sysfs_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count);

struct kobj_attribute sysfs_attribute = __ATTR(sysfs_value, 0660, sysfs_show, sysfs_store);

/* This function will be called when we read the sysfs file*/
static ssize_t sysfs_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
{
    pr_info("Sysfs - Read operation\n");
    return 0;
}

/* This function will be called when we write the sysfs file*/
static ssize_t sysfs_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
{
    pr_info("Sysfs - Write operation\n");
    return count;
}

static int
__init hello_world_init(void)
{
    int error = 0;

    /* 01. It will create airectory under "/sys", [firmware_kobj, class_kobj] */
    mdev.kobj_ref = kobject_create_and_add("bb_sysfs", kernel_kobj);
    if (!mdev.kobj_ref)
        return -ENOMEM;

    /* 02. Creating sys entry under "/sys/bbb_gpios/" */
    error = sysfs_create_file(mdev.kobj_ref, &sysfs_attribute.attr);
    if (error) {
        pr_info("failed to create the sysfs file\n");
        kobject_put(mdev.kobj_ref);
    }

    pr_info("Sysfs Character Device Initialized\n");
    return 0;

rm_kobj:
    kobject_put(mdev.kobj_ref);
    return -1;
}

static void
__exit hello_world_exit(void)
{
    /* 01. Remove the sysfs entry */
    sysfs_remove_file(mdev.kobj_ref, &sysfs_attribute.attr);

    /* 02. Remove the directory created under "/sys" */
    kobject_put(mdev.kobj_ref);

    pr_info("Sysfs Character Device Removed\n");
}
```
### T·∫°o Directory
`kobject_create_and_add` n·∫øu t·∫°o ƒë∆∞·ª£c h√†m n√†y th√¨ s·∫Ω c√≥ t√™n **bb_sysfs** chung h√†ng v·ªõi m·∫•y c√°i class, bus, block c√°c th·ª©, param th·ª© 2 l√† NUM v√¨ th√™m m·ªõi. Param th·ª© 2 [firmware_kobj, class_kobj] c√≥ th·ªÉ ch·ªçn 1 trong 2 n√†y n·∫øu firmware th√¨ s·∫Ω n·∫±m trong m·ª•c firware.

### T·∫°o ra file
`sysfs_create_file(mdev.kobj_ref, &sysfs_attribute.attr)`, param th·ª© nh·∫•t d√πng ƒë·ªÉ ƒëi·ªÅn c√°i direction v·ª´a t·∫°o, ƒë·ªëi s·ªë th·ª© 2 ƒëƒÉng k√Ω 2 h√†m.
ƒê·ªëi s·ªë th·ª© 2 `struct kobj_attribute sysfs_attribute = __ATTR(sysfs_value, 0660, sysfs_show, sysfs_store);` li√™n quan ƒë·∫øn n√†y show t∆∞∆°ng ·ª©ng v·ªõi cat, store t∆∞∆°ng ·ª©ng echo.

### Ch·∫°y test
```bash
root@arm:/sys# ls
bb_sysfs  block  bus  class  dev  devices  firmware  fs  kernel  module  power
root@arm:/sys# ls -l b
bb_sysfs/ block/    bus/
root@arm:/sys# ls -l bb_sysfs/
total 0
-rw-rw---- 1 root root 4096 Nov 26 15:39 sysfs_value
root@arm:/sys# ls
bb_sysfs  block  bus  class  dev  devices  firmware  fs  kernel  module  power
root@arm:/sys# cd bb_sysfs/
root@arm:/sys/bb_sysfs# la
bash: la: command not found
root@arm:/sys/bb_sysfs# ls
sysfs_value
root@arm:/sys/bb_sysfs# cat sysfs_value
root@arm:/sys/bb_sysfs# echo 1 > sysfs_value
root@arm:/sys/bb_sysfs# dmesg | tail
[   23.634384] SMSC LAN8710/LAN8720 4a101000.mdio:00: attached PHY driver [SMSC LAN8710/LAN8720] (mii_bus:phy_addr=4a101000.mdio:00, irq=POLL)
[   26.733715] IPv6: ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
[   26.740190] cpsw 4a100000.ethernet eth0: Link is Up - 100Mbps/Full - flow control off
[   83.521927] systemd-journald[142]: File /var/log/journal/5d7acfce99624d61b2b259cb6c0cf8a2/user-1000.journal corrupted or uncleanly shut down, renaming and replacing.
[ 8182.236536] bb_sysfs: loading out-of-tree module taints kernel.
[ 8182.243767] Sysfs Character Device Initialized
[ 8323.860043] Sysfs Character Device Removed
[ 8330.018232] Sysfs Character Device Initialized
[ 8488.372555] Sysfs - Read operation
[ 8517.838778] Sysfs - Write operation
root@arm:/sys/bb_sysfs#
```

### T·∫°i group c√°c ch·ª©c nƒÉng
```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/cdev.h>
#include <linux/device.h>

#define DRIVER_AUTHOR "tranconghoa24@gmail.com"
#define DRIVER_DESC "A simple sysfs character device example"

struct m_foo_dev {
    struct kobject *kobj_ref;
}mdev;

/************ Function Prototypes ***********/
static int __init hello_world_init(void);
static void __exit hello_world_exit(void);

/************ Sysfs Function ****************/
static ssize_t value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);
static ssize_t value_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count);

static ssize_t direction_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);
static ssize_t direction_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count);

struct kobj_attribute value = __ATTR(value, 0660, value_show, value_store);
struct kobj_attribute direction = __ATTR(direction, 0660, direction_show, direction_store);

/* This function will be called when we read the sysfs file*/
static ssize_t value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
{
    pr_info("Value - Read operation\n");
    return 0;
}

/* This function will be called when we write the sysfs file*/
static ssize_t value_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
{
    pr_info("Value - Write operation\n");
    return count;
}

/* This function will be called when we read the sysfs file*/
static ssize_t direction_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
{
    pr_info("Direction - Read operation\n");
    return 0;
}

/* This function will be called when we write the sysfs file*/
static ssize_t direction_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
{
    pr_info("Direction - Write operation\n");
    return count;
}

/*Initialize group attrs*/
static struct attribute *attrs[] = {
    &direction.attr,
    &value.attr,
    NULL,
};

static struct attribute_group attr_group = {
    .attrs = attrs,
};

static int
__init hello_world_init(void)
{
    int error = 0;

    /* 01. It will create airectory under "/sys", [firmware_kobj, class_kobj] */
    mdev.kobj_ref = kobject_create_and_add("bb_sysfs", NULL);
    if (!mdev.kobj_ref)
        return -ENOMEM;

    /* 02. Creating sys entry under "/sys/bbb_gpios/" */
    // error = sysfs_create_file(mdev.kobj_ref, &sysfs_attribute.attr);
    // if (error) {
    //     pr_info("failed to create the sysfs file\n");
    //     goto rm_kobj;
    // }

    /* 03. Creating group sys entry under "/sys/bbb_gpios/" */
    error = sysfs_create_group(mdev.kobj_ref, &attr_group);
    if (error) {
        pr_info("failed to create group attribute..........\n");
        goto rm_kobj;
    }

    pr_info("Sysfs Character Device Initialized\n");
    return 0;

rm_kobj:
    kobject_put(mdev.kobj_ref);
    return -1;
}

static void
__exit hello_world_exit(void)
{
    /* 01. Remove the sysfs entry */
    // sysfs_remove_file(mdev.kobj_ref, &sysfs_attribute.attr);

    /* 01. Remove the sysfs entry */
    sysfs_remove_group(mdev.kobj_ref, &attr_group);

    /* 02. Remove the directory created under "/sys" */
    kobject_put(mdev.kobj_ref);

    pr_info("Sysfs Character Device Removed\n");
}

module_init(hello_world_init);
module_exit(hello_world_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
```
V√≠ d·ª• khi ch·∫°y
```bash

root@arm:/home/debian/Learn# insmod bb_sysfs.ko
root@arm:/home/debian/Learn# cd sys
bash: cd: sys: No such file or directory
root@arm:/home/debian/Learn# ls
bb_sysfs.ko  exam.ko  gpio.ko  hello  hello.ko  hello.o  threadExample
root@arm:/home/debian/Learn# cd /sys
root@arm:/sys# ls
bb_sysfs  block  bus  class  dev  devices  firmware  fs  kernel  module  power
root@arm:/sys# cd bb_sysfs/
root@arm:/sys/bb_sysfs# ls
direction  value
root@arm:/sys/bb_sysfs# cat direction
root@arm:/sys/bb_sysfs# cat value
root@arm:/sys/bb_sysfs# echo 1 > direction
root@arm:/sys/bb_sysfs# echo 1 > value
root@arm:/sys/bb_sysfs# dmesg | tail
[ 6706.867122] Direction - Read operation
[ 6711.901041] Value - Read operation
[ 6732.055514] Direction - Write operation
[ 6738.466855] Value - Write operation
[ 6848.651512] Sysfs Character Device Removed
[ 6919.521015] Sysfs Character Device Initialized
[ 6981.959820] Direction - Read operation
[ 6985.778012] Value - Read operation
[ 6994.604508] Direction - Write operation
[ 7001.249923] Value - Write operation
root@arm:/sys/bb_sysfs#
```
Sau khi ch·∫°y n√®.

## Check g·ª≠i rw v√†o trong file thu·ªôc t√≠nh

## Control ph·∫ßn c·ª©ng

