---
title: "ENUM"
date: 2025-07-23 21:34:50 +0800
categories: [C]
tags: [C]
---

# üìñ Enum trong C

T√†i li·ªáu n√†y cung c·∫•p ki·∫øn th·ª©c c∆° b·∫£n, v√≠ d·ª• th·ª±c t·∫ø v√† gi·∫£i th√≠ch r√µ r√†ng v·ªÅ **enum** trong l·∫≠p tr√¨nh C.


## üß† T·ªïng quan

`enum` (vi·∫øt t·∫Øt c·ªßa "enumeration") l√† m·ªôt ki·ªÉu d·ªØ li·ªáu trong C, ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë·ªãnh nghƒ©a m·ªôt t·∫≠p h·ª£p c√°c h·∫±ng s·ªë nguy√™n c√≥ t√™n. N√≥ gi√∫p m√£ ngu·ªìn d·ªÖ ƒë·ªçc, d·ªÖ hi·ªÉu v√† d·ªÖ b·∫£o tr√¨ h∆°n.

---

## ‚öôÔ∏è C√°ch khai b√°o enum

### C√∫ ph√°p:
```c
enum EnumName {
    constant1,
    constant2,
    // C√°c h·∫±ng s·ªë kh√°c
};
```
## V√≠ d·ª•
### V√≠ d·ª• 1
![alt text](/assets/C/enum_1.png)
### V√≠ d·ª• 2
![alt text](/assets/C/enum_2.png)
Ch√∫ng ta r√∫t ra k·∫øt lu·∫≠n sau:
- N·∫øu ch√∫ng ta kh√¥ng g√°n gi√° tr·ªã cho t√™n enum m·ªôt c√°ch r√µ r√†ng, tr√¨nh bi√™n d·ªãch theo m·∫∑c ƒë·ªãnh g√°n gi√° tr·ªã b·∫Øt ƒë·∫ßu t·ª´ 0. (Xem v√≠ d·ª• 1)
- Ch√∫ng ta c√≥ th·ªÉ g√°n 1 gi√° tr·ªã b·∫•t k·ª≥ cho m·ªôt ph·∫ßn t·ª≠ c·ªßa enum. T·∫•t c·∫£ c√°c t√™n ch∆∞a ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh nh·∫≠n gi√° tr·ªã l√† gi√° tr·ªã c·ªßa t√™n tr∆∞·ªõc ƒë√≥ c·ªông v·ªõi m·ªôt.

## üìã ·ª®ng d·ª•ng c·ªßa enum
1. Qu·∫£n l√Ω tr·∫°ng th√°i:
V√≠ d·ª•: Tr·∫°ng th√°i c·ªßa m·ªôt thi·∫øt b·ªã (ON, OFF, STANDBY).
2. X·ª≠ l√Ω ng√†y trong tu·∫ßn:
V√≠ d·ª•: MONDAY, TUESDAY, ...
3. M√£ l·ªói:
V√≠ d·ª•: SUCCESS, ERROR, TIMEOUT.
4. ƒêi·ªÅu khi·ªÉn giao ti·∫øp:
V√≠ d·ª•: C√°c l·ªánh (START, STOP, PAUSE).

## üìã ·ª®ng d·ª•ng c·ªßa enum trong Embedded
### 1. Qu·∫£n l√Ω tr·∫°ng th√°i h·ªá th·ªëng (State Machine)
enum gi√∫p qu·∫£n l√Ω c√°c tr·∫°ng th√°i trong m·ªôt h·ªá th·ªëng ƒëi·ªÅu khi·ªÉn ho·∫∑c m√°y tr·∫°ng th√°i. ƒêi·ªÅu n√†y gi√∫p m√£ ngu·ªìn tr·ªü n√™n d·ªÖ hi·ªÉu h∆°n v√† tr√°nh ƒë∆∞·ª£c nh·ªØng l·ªói khi s·ª≠ d·ª•ng c√°c gi√° tr·ªã tr·∫°ng th√°i d·∫°ng s·ªë.
**V√≠ d·ª•:** Qu·∫£n l√Ω tr·∫°ng th√°i ƒë·ªông c∆° (Motor State)
```c
#include <stdio.h>

// ƒê·ªãnh nghƒ©a c√°c tr·∫°ng th√°i c·ªßa ƒë·ªông c∆°
typedef enum {
    MOTOR_OFF,    // ƒê·ªông c∆° t·∫Øt
    MOTOR_START,  // ƒê·ªông c∆° ƒëang kh·ªüi ƒë·ªông
    MOTOR_RUNNING,// ƒê·ªông c∆° ƒëang ch·∫°y
    MOTOR_STOP    // ƒê·ªông c∆° d·ª´ng
} MotorState;

MotorState currentState = MOTOR_OFF;

void motorControl(MotorState state) {
    switch(state) {
        case MOTOR_OFF:
            printf("Motor is OFF\n");
            break;
        case MOTOR_START:
            printf("Motor is starting...\n");
            break;
        case MOTOR_RUNNING:
            printf("Motor is running\n");
            break;
        case MOTOR_STOP:
            printf("Motor is stopping...\n");
            break;
        default:
            printf("Unknown motor state\n");
            break;
    }
}

int main() {
    motorControl(MOTOR_START);
    currentState = MOTOR_RUNNING;
    motorControl(currentState);
    currentState = MOTOR_STOP;
    motorControl(currentState);
    
    return 0;
}
```
**Gi·∫£i th√≠ch:**
B·∫°n c√≥ th·ªÉ th·∫•y r·∫±ng enum gi√∫p ƒë·ªãnh nghƒ©a c√°c tr·∫°ng th√°i c√≥ √Ω nghƒ©a (MOTOR_OFF, MOTOR_START, v.v.), tr√°nh ph·∫£i s·ª≠ d·ª•ng s·ªë nguy√™n m√† ng∆∞·ªùi ƒë·ªçc kh√≥ hi·ªÉu.

D·ªÖ d√†ng thay ƒë·ªïi ho·∫∑c m·ªü r·ªông m√† kh√¥ng l√†m ·∫£nh h∆∞·ªüng ƒë·∫øn ph·∫ßn c√≤n l·∫°i c·ªßa ch∆∞∆°ng tr√¨nh.
### 2. ƒê∆°n gi·∫£n h√≥a m√£ khi l√†m vi·ªác v·ªõi c·ªù (Flags)
Khi l√†m vi·ªác v·ªõi c√°c bi·∫øn c·ªù ƒë·ªÉ ch·ªâ c√°c t√≠nh nƒÉng c·ªßa ph·∫ßn c·ª©ng ho·∫∑c tr·∫°ng th√°i ph·∫ßn m·ªÅm, enum c√≥ th·ªÉ gi√∫p b·∫°n d·ªÖ d√†ng qu·∫£n l√Ω.

**V√≠ d·ª•:** Qu·∫£n l√Ω c√°c c·ªù tr·∫°ng th√°i trong m·ªôt h·ªá th·ªëng
```c
#include <stdio.h>

typedef enum {
    FLAG_NONE = 0,    // Kh√¥ng c√≥ c·ªù n√†o
    FLAG_ERROR = 1,   // C·ªù l·ªói
    FLAG_READY = 2,   // C·ªù s·∫µn s√†ng
    FLAG_BUSY = 4     // C·ªù ƒëang b·∫≠n
} FlagStatus;

FlagStatus status = FLAG_NONE;

void checkStatus(FlagStatus status) {
    if (status & FLAG_ERROR) {
        printf("Error Flag is set!\n");
    }
    if (status & FLAG_READY) {
        printf("Ready Flag is set!\n");
    }
    if (status & FLAG_BUSY) {
        printf("Busy Flag is set!\n");
    }
}

int main() {
    status = FLAG_READY | FLAG_BUSY; // C·∫£ 2 c·ªù READY v√† BUSY ƒë·ªÅu ƒë∆∞·ª£c b·∫≠t
    checkStatus(status);

    status |= FLAG_ERROR;  // B·∫≠t c·ªù l·ªói
    checkStatus(status);

    return 0;
}
```
**Gi·∫£i th√≠ch:**
enum gi√∫p b·∫°n d·ªÖ d√†ng x√°c ƒë·ªãnh c√°c gi√° tr·ªã c·ªù v√† ƒë·∫£m b·∫£o m√£ ngu·ªìn d·ªÖ ƒë·ªçc h∆°n, tr√°nh vi·ªác s·ª≠ d·ª•ng c√°c s·ªë nguy√™n kh√¥ng c√≥ √Ω nghƒ©a.

Vi·ªác k·∫øt h·ª£p c√°c c·ªù v·ªõi to√°n t·ª≠ bitwise (|, &) gi√∫p b·∫°n qu·∫£n l√Ω nhi·ªÅu tr·∫°ng th√°i trong c√πng m·ªôt bi·∫øn.

### 3. ƒêi·ªÅu khi·ªÉn c√°c ch·∫ø ƒë·ªô l√†m vi·ªác c·ªßa thi·∫øt b·ªã
`enum` th∆∞·ªùng ƒë∆∞·ª£c d√πng ƒë·ªÉ qu·∫£n l√Ω c√°c ch·∫ø ƒë·ªô ho·∫°t ƒë·ªông c·ªßa ph·∫ßn c·ª©ng, v√≠ d·ª• nh∆∞ ch·∫ø ƒë·ªô l√†m vi·ªác c·ªßa m·ªôt c·∫£m bi·∫øn, giao th·ª©c truy·ªÅn th√¥ng, ho·∫∑c ch·∫ø ƒë·ªô ho·∫°t ƒë·ªông c·ªßa b·ªô vi x·ª≠ l√Ω.

**V√≠ d·ª•:** Qu·∫£n l√Ω c√°c ch·∫ø ƒë·ªô ho·∫°t ƒë·ªông c·ªßa c·∫£m bi·∫øn
```c
#include <stdio.h>

// ƒê·ªãnh nghƒ©a c√°c ch·∫ø ƒë·ªô ho·∫°t ƒë·ªông c·ªßa c·∫£m bi·∫øn
typedef enum {
    SENSOR_IDLE,        // Ch·∫ø ƒë·ªô ch·ªù
    SENSOR_ACTIVE,      // Ch·∫ø ƒë·ªô ho·∫°t ƒë·ªông
    SENSOR_SLEEP        // Ch·∫ø ƒë·ªô ng·ªß
} SensorMode;

SensorMode currentMode = SENSOR_IDLE;

void setSensorMode(SensorMode mode) {
    switch (mode) {
        case SENSOR_IDLE:
            printf("Sensor is idle.\n");
            break;
        case SENSOR_ACTIVE:
            printf("Sensor is active.\n");
            break;
        case SENSOR_SLEEP:
            printf("Sensor is sleeping.\n");
            break;
        default:
            printf("Unknown mode.\n");
            break;
    }
}

int main() {
    setSensorMode(SENSOR_ACTIVE);   // ƒê·∫∑t ch·∫ø ƒë·ªô ho·∫°t ƒë·ªông
    currentMode = SENSOR_SLEEP;
    setSensorMode(currentMode);     // ƒê·∫∑t ch·∫ø ƒë·ªô ng·ªß

    return 0;
}
```
**Gi·∫£i th√≠ch:**
enum gi√∫p b·∫°n d·ªÖ d√†ng qu·∫£n l√Ω c√°c ch·∫ø ƒë·ªô ho·∫°t ƒë·ªông c·ªßa c·∫£m bi·∫øn, gi√∫p vi·ªác thay ƒë·ªïi ch·∫ø ƒë·ªô d·ªÖ d√†ng v√† gi·∫£m thi·ªÉu l·ªói.

### 4. Qu·∫£n l√Ω c√°c lo·∫°i giao th·ª©c truy·ªÅn th√¥ng
Khi l√†m vi·ªác v·ªõi nhi·ªÅu giao th·ª©c truy·ªÅn th√¥ng nh∆∞ UART, SPI, I2C, b·∫°n c√≥ th·ªÉ d√πng `enum` ƒë·ªÉ x√°c ƒë·ªãnh c√°c lo·∫°i giao th·ª©c v√† d·ªÖ d√†ng thay ƒë·ªïi.
**V√≠ d·ª•:** Ch·ªçn giao th·ª©c truy·ªÅn th√¥ng cho thi·∫øt b·ªã
```c
#include <stdio.h>

typedef enum {
    PROTOCOL_UART,    // Giao th·ª©c UART
    PROTOCOL_SPI,     // Giao th·ª©c SPI
    PROTOCOL_I2C      // Giao th·ª©c I2C
} CommunicationProtocol;

void selectProtocol(CommunicationProtocol protocol) {
    switch (protocol) {
        case PROTOCOL_UART:
            printf("Using UART protocol\n");
            break;
        case PROTOCOL_SPI:
            printf("Using SPI protocol\n");
            break;
        case PROTOCOL_I2C:
            printf("Using I2C protocol\n");
            break;
        default:
            printf("Unknown protocol\n");
            break;
    }
}

int main() {
    selectProtocol(PROTOCOL_SPI);  // L·ª±a ch·ªçn giao th·ª©c SPI
    selectProtocol(PROTOCOL_I2C);  // L·ª±a ch·ªçn giao th·ª©c I2C

    return 0;
}
```
**Gi·∫£i th√≠ch:**
enum gi√∫p x√°c ƒë·ªãnh r√µ r√†ng c√°c giao th·ª©c truy·ªÅn th√¥ng c·∫ßn s·ª≠ d·ª•ng, v√† b·∫°n c√≥ th·ªÉ d·ªÖ d√†ng thay ƒë·ªïi ho·∫∑c th√™m c√°c giao th·ª©c kh√°c trong t∆∞∆°ng lai m√† kh√¥ng l√†m ·∫£nh h∆∞·ªüng ƒë·∫øn ph·∫ßn c√≤n l·∫°i c·ªßa m√£ ngu·ªìn.