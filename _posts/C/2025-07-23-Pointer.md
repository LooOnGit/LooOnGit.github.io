---
title: "POINTER"
date: 2025-07-24 19:44:32 +0800
categories: [C]
tags: [C]
---

# 💡 Hướng dẫn về con trỏ trong c

Tài liệu này cung cấp kiến thức cơ bản, ví dụ thực tế và giải thích về **con trỏ** trong lập trình c.


## 🧠 Tổng quan

con trỏ là một biến trong c dùng để **lưu trữ địa chỉ của một biến khác**. Việc sử dụng con trỏ giúp tăng tính linh hoạt và hiệu suất của chương trình, đặc biệt khi làm việc với mảng, cấp phát bộ nhớ động, và khi cần truyền tham chiếu tới các hàm. 
Nhưng biến con trỏ không lưu giá trị bình thường, nó là biến trỏ tới 1 địa chỉ khác, tức mang giá trị là 1 địa chỉ trong RAM.

---

## 🏷️ Khái niệm cơ bản về con trỏ

- **con trỏ** là một biến chứa địa chỉ của một biến khác.
- con trỏ có thể trỏ đến bất kỳ loại dữ liệu nào, chẳng hạn như kiểu nguyên thủy (`int`, `float`, ...) hoặc kiểu cấu trúc (`struct`).
- Để khai báo con trỏ, chúng ta sử dụng dấu `*`.

---

## ⚙️ Khai báo và sử dụng con trỏ

### cách khai báo con trỏ:

**kiểu dữ liệu** * **tên biến**

Trong đó:

- **Kiểu dữ liệu** có thể là: void, char, int, float, double,...
- Dấu * trước **tên biến** là ký hiệu báo cho trình biên dịch biết ta đang khai báo con trỏ.

**Ví dụ 1:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

int main()
{
    int x = 77;
    int *pt = &x;
    printf("Gia tri cua x = %d \n", *pt);
    printf("Dia chi cua x la %x hoac %x \n", &x, pt);
    printf("Dia chi cua con tro pt la %0x \n", &pt);
    return 0;
}
```
**Ví dụ 1:**
```c
#include <stdio.h>

int main() {
    int x = 1000;
    int *pt;        
    pt = &x;

    // In ra địa chỉ của con trỏ pt
    printf("&pt = %p \n", (void*)&pt);  // &pt: Địa chỉ của con trỏ pt

    // In ra địa chỉ mà con trỏ pt trỏ đến (địa chỉ của x)
    printf("pt = %p \n", (void*)pt);    // pt: Địa chỉ mà pt trỏ đến (địa chỉ của x)

    // In ra giá trị tại địa chỉ mà con trỏ pt trỏ đến (giá trị của x)
    printf("*pt = %d \n", *pt);        // *pt: Giá trị tại địa chỉ mà pt trỏ đến (giá trị của x)

    return 0;
}
```
- **&pt**: địa chỉ của con trỏ trên RAM
- **pt**: địa chỉ con trỏ trỏ đến trên RAM.
- **pt**: giá trị tại vùng địa chỉ con trỏ trỏ đến trên RAM
---

## ➕ Toán tử Tăng Giảm con trỏ

Giống như một biến thông thường, con trỏ cũng có toán tử tăng giảm, tuy nhiên khi sử dụng toán tử tăng/giảm trên biến con trỏ, nó sẽ nhảy sang phần tử liền kề chứ không phải tăng/giảm giá trị lên 1 đơn vị.

![alt text](/assets/C/pointer2.png)

## 🧑‍💻 con trỏ và mảng
con trỏ và mảng có một mối quan hệ chặt chẽ trong c. Khi khai báo mảng, tên mảng chính là địa chỉ của phần tử đầu tiên trong mảng.
![alt text](/assets/C/pointer1.png)

## 🧩 con trỏ tới hàm

**Truyền địa chỉ biến**
Khi chúng ta truyền vào tham trị (truyền vào giá trị biến) chứ không phải truyền vào tham chiếu (truyền vào địa chỉ biến) thì mặc dù trong hàm đã thay đổi giá trị các biến nhưng sau khi kết thúc hàm giá trị biến vẫn chưa thể thay đổi được. Và chúng ta sẽ phải sửa lại bằng cách truyền vào tham chiếu chính là địa chỉ của biến thông qua con trỏ.

```c
#include <stdio.h>

void hoanVi_thamchie(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

void hoanVi_thamtri(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}

int main()
{
    int a = 10, b = 1000;
    printf("Truoc khi goi ham hoan vi: a = %d, b = %d \n", a, b);
    hoanVi_thamtri(a, b);
    printf("Sau khi goi ham hoan vi: a = %d, b = %d \n", a, b);
    hoanVi_thamchie(&a, &b);
    printf("Sau khi goi ham hoan vi: a = %d, b = %d \n", a, b);
    return 0;
}
```
**Truyền địa chỉ của mảng**
chúng ta có thể sử dụng con trỏ để thay đổi giá trị các phần tử mảng. Địa chỉ của mảng cũng chính là địa chỉ phần tử đầu tiên của mảng.

**Ví dụ:**
```c
#include <stdio.h>
#include <string.h>

int mang[100] = {0};

void NhapMang(int *pt, int *n)
{
    printf("Nhap vao so phan tu mang: ");
    scanf("%d", n);
    printf("Nhap Mang\n");
    for (int i = 0; i < *n; i++)
    {
        printf("mang[%d] = ", i); // gán giá trị cho phần tử mảng thông qua con trỏ
        scanf("%d", pt); // trỏ con trỏ pt đến phần tử mảng tiếp theo
        pt = pt + 1;
    }
}

void InMang(int *pt, int n)
{
    printf("In Mang\n");
    for (int i = 0; i < n; i++)
    {
        printf("mang[%d] = %d\n", i, *pt);
        pt = pt + 1;
    }
}

int main()
{
    int phan_tu_mang;
    NhapMang(mang, &phan_tu_mang);
    InMang(mang, phan_tu_mang);
}
```

**Hàm trả về con trỏ**
Tương tự như trong c++, thì trong c cũng cho phép hàm trả về một con trỏ.

**cú pháp**
```c
kieudulieu_tra_ve *ten_ham()
{
    // user code
}
```

**Ví dụ:**

```c
#include <stdio.h>

int *timSoLonNhat(int x, int y)
{
    if (x > y)
    {
        return &x; // trả về 1 địa chỉ
    }
    else
    {
        return &y; // trả về 1 địa chỉ
    }
}

int main()
{
    int *result;
    int a = 11;
    int b = 15;
    result = timSoLonNhat(a, b); // truyền vào giá trị của a và b
    printf("So lon nhat = %d \n", *result);
    return 0;
}
```

## 🧩 Con trỏ hàm
Con trỏ hàm (function pointer) là một biến đặc biệt có thể lưu trữ địa chỉ của một hàm. Thông qua con trỏ hàm, bạn có thể gọi hàm một cách gián tiếp.

Cú pháp:
```c
kiểu_trả_về (*tên_con_trỏ)(danh_sách_tham_số);
```

Ví dụ:
```c
int (*ptr_func)(int, int);  // Con trỏ trỏ đến hàm có 2 tham số int và trả về int
void (*ptr_void)();         // Con trỏ trỏ đến hàm không có tham số và không trả về gì
```
**Ví dụ:**
Đoạn chương trình dưới đây là hoạt động dựa trên chạy `bootloader` khi trước đó đã nạp 2 firmware1 và fireware2 được lưu ở 2 vùng nhó trên flash thứ tự là `0x8004004` và `0x8008004` khi nhấn nút thì vào địa chỉ `0x8004004` và đưa địa chỉ này cho con trỏ hàm và gọi con trỏ hàm chạy thôi.
```c
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();

    uint32_t* rst_addr_vttb = 0;

  void (*con_tro_ham)() = 0;
  if(HAL_GPIO_ReadPin(GPIOA,  GPIO_PIN_0) == GPIO_PIN_SET){
  	  rst_addr_vttb = 0x8004004;
  }else{
  	  rst_addr_vttb = 0x8008004;
  }
  con_tro_ham = *rst_addr_vttb;
  con_tro_ham();

  while (1)
  {

  }

}
```


**Kết quả:**
Segmentation fault (core dumped)


## 🧩 Con trỏ NULL 
Con trỏ NULL là một con trỏ đặc biệt trong C/C++ được dùng để biểu diễn rằng nó không trỏ đến bất kỳ địa chỉ hợp lệ nào trong bộ nhớ.

Khi 1 con trỏ khởi tạo không trỏ đến vùng nhớ nào thì nên để null, không để null thì sẽ có thể sinh ra `Segmentation Fault`.

### Vậy Segmentation Fault là gì?
- Segmentation Fault (hay viết tắt là Segfault) là một lỗi runtime xảy ra khi chương trình truy cập vào vùng nhớ không được phép.
**Các nguyên nhân dẫn đến Segmentation Fault**:
- 📌 Truy cập con trỏ chưa gán (uninitialized pointer)
```c
int *p;
*p = 10;   // ❌ p chưa trỏ tới đâu -> segfault
```
- 📌 Dereference con trỏ NULL
```c
int *p = NULL;
*p = 5;    // ❌ NULL không trỏ tới vùng nhớ hợp lệ
```
- 📌 Vượt quá phạm vi mảng (out-of-bounds)
```c
int arr[5];
arr[10] = 100;  // ❌ truy cập ngoài phạm vi mảng
```
- 📌 Sử dụng con trỏ đã free
```c
int *p = malloc(sizeof(int));
free(p);
*p = 50;   // ❌ vùng nhớ đã được thu hồi
```
- 📌 Stack overflow (gọi hàm đệ quy vô hạn)
```c
void foo() {
    foo();   // ❌ đệ quy vô hạn -> tràn stack -> segfault
}
```

## 🧩 Con trỏ void
- Nó có thể trỏ đến bất kỳ kiểu dữ liệu nào, nhưng không biết kích thước dữ liệu mà nó trỏ tới.
**Vì vậy:**
- Không thể dereference trực tiếp (*ptr). (giá trị tại vùng nhớ mà con trỏ đó trỏ đến).
- Không thể thực hiện phép toán con trỏ (như ptr++). Vì không biết tăng nhiêu byte.
- Phải ép kiểu về con trỏ đúng trước khi dùng.
```c
void *p;
int x = 5;
p = &x;
printf("%d", *(int*)p);   // ✅ ép kiểu về int*
```

```c
#include <stdio.h>

int main() {
    int a = 10;
    float b = 3.14;
    char c = 'X';

    void *ptr;   // con trỏ void

    ptr = &a;
    printf("Gia tri a: %d\n", *(int*)ptr);   // ép kiểu về int*

    ptr = &b;
    printf("Gia tri b: %.2f\n", *(float*)ptr); // ép kiểu về float*

    ptr = &c;
    printf("Gia tri c: %c\n", *(char*)ptr);   // ép kiểu về char*

    return 0;
}
```
## ⚠️ Lưu ý khi sử dụng con trỏ
- Không truy cập bộ nhớ không hợp lệ: Truy cập con trỏ không được gán giá trị hoặc trỏ đến bộ nhớ không hợp lệ sẽ gây lỗi.
- Giải phóng bộ nhớ: Nếu bạn sử dụng con trỏ để cấp phát bộ nhớ động (ví dụ với malloc()), hãy nhớ giải phóng bộ nhớ bằng free() khi không sử dụng nữa.
- Tránh sử dụng con trỏ null: Trước khi dereference một con trỏ, luôn kiểm tra xem nó có phải là null không.