---
title: "UNION"
date: 2025-07-24 19:37:00 +0800
categories: [C]
tags: [C]
---

# 📖 Hướng dẫn về Union trong c

ví dụ thực tế và giải thích rõ ràng về **union** trong lập trình c.

## 🧠 Tổng quan

`Union` là dữ liệu đặc biệt trong ngôn ngữ c cho phép bạn dự trữ các kiểu dữ liệu khác nhau trong cùng 1 vùng nhớ. Bạn có thể định nghĩa Union với rất nhiều tham số, nhưng chỉ một thành phần chứa giá trị tại một thời điểm.

---

## ⚙️ cách khai báo union

### Khai báo tường minh:
```c
union unionName {
    dataType member1;
    dataType member2;
    // các thành viên khác
};
```
#### Ví dụ:
```c
union Hoclaptrinh {
    int i;
    float f;
    char chuoi[50];
};
```
### Khai báo không tường minh (sử dụng typedef):
```c
typedef union {
    dataType member1;
    dataType member2;
    // các thành viên khác
} unionName;
```
#### Ví dụ:
```c
typedef union {
    int i;
    float f;
    char chuoi[50];
} Hoclaptrinh;
```
Khác với struct là về cách quản lý bộ nhớ, còn cách dùng thì giống nhau.

## 🔍 Truy cập thành viên của union
các thành viên của `union` được truy cập bằng toán tử `.` (dấu chấm), tương tự như `struct`.
### Ví dụ:
```c
#include <stdio.h>

union Data {
    int i;
    float f;
    char str[20];
};

int main() {
    union Data data;

    data.i = 10;
    printf("data.i: %d\n", data.i);

    data.f = 220.5;
    printf("data.f: %.2f\n", data.f);

    // Lưu ý: Giá trị của `data.i` sẽ bị ghi đè bởi `data.f`
    return 0;
}
```
## 🔄 Sự khác biệt giữa struct và union
### 1. Về bộ nhớ
- **struct**: Mỗi thành viên có vùng nhớ riêng biệt
- **union**: Các thành viên chia sẻ cùng một vùng nhớ

### 2. Về kích thước
- **struct**: Tổng kích thước của tất cả thành viên
- **union**: Kích thước của thành viên lớn nhất

### 3. Về truy cập đồng thời
- **struct**: Các thành viên có thể được truy cập đồng thời
- **union**: Chỉ một thành viên có thể được truy cập tại một thời điểm

### 4. Về ứng dụng
- **struct**: 
  - Lưu trữ dữ liệu phức tạp
  - Các thành viên độc lập với nhau
- **union**:
  - Tiết kiệm bộ nhớ 
  - Dùng khi các thành viên không cần tồn tại đồng thời
  
![alt text](/assets/C/union2.png)
### Ví dụ:
```c
#include <stdio.h>
#include <string.h>

typedef union gt {
    int x;
    float y;
    char c[30];
} gt_t;
int main() {
    gt_t a;
    a.x = 100;
    a.y = 3.14;
    strcpy(a.c, "Loo_D");

    printf("x là %d\n", a.x);
    printf("y là %.2f\n", a.y);
    printf("c là %s\n", a.c);

    return 0;
}
```
![alt text](/assets/C/union2.png)

Union nó tìm ra phần tử có kích thước lớn nhất và nó chỉ cấp phát ô nhớ cho phần tử có kích thước lớn nhất.

Ví dụ trên khai báo c gồm 30 phần tử nên 30 byte là lớn nhất nên chỉ cấp phát cho c.

Khi vào hàm main hoạt động thì gán phần tử x bằng 100 thì lúc này nó ghi giá trị vào 30byte vừa cấp phát. Và tiếp theo nó gán y bằng 3.14 thì lúc này y ghi đè giá trị vào 30 byte thì lúc này x không còn ghi trong đó nữa nên sinh ra giá trị rác.

Khi thực hiện lệnh strcpy copy "Loo_D" vào phần tử c thì lúc này nó lại ghi đè lên y là ghi vào 30byte đó nên y cũng mất. Vì thế khi in ra thì x và y không đúng.

**Kết luận: Union vd trên có kích thước 30byte và các phần tử sử dụng chung 30 byte đó. Và union sinh ra để tiết kiệm ô nhớ vì tại 1 thời điểm chỉ sử dụng 1 phần tử được sử dụng và có giá trị hợp lệ.
### Ví dụ: 
```c
typedef struct {
    char ten[30];
    int _level;
} giangvien_info_t;

typedef struct {
    char ten[30];
    int _class;
} sinhvien_info_t;

typedef union {
    giangvien_info_t gv;
    sinhvien_info_t sv;
} info_t;

int main() {
    info_t info; // 34 bytes

    printf("Nhap ten giang vien: ");
    gets(info.gv.ten);
    printf("Ten gv: %s\n", info.gv.ten);

    printf("Nhap ten sinh vien: ");
    gets(info.sv.ten);
    printf("Ten sv: %s\n", info.sv.ten);

    return 0;
}
```
## 💡 Ứng dụng của Union trong Embedded Systems
### 1. **Quản lý thanh ghi**
```c
#include <stdio.h>
#include <stdint.h>

// Định nghĩa union cho motor control
typedef union {
    struct {
        uint8_t start   :1;   // Bit 0: Bật/tắt động cơ
        uint8_t stop    :1;   // Bit 1: Dừng động cơ
        uint8_t reverse :1;   // Bit 2: Đảo chiều động cơ
        uint8_t fault   :1;   // Bit 3: Báo lỗi
        uint8_t reserved:4;   // Bit 4-7: Dự phòng
    } bits;
    uint8_t all;              // Truy cập toàn bộ 8 bits
} MotorcontrolReg;

MotorcontrolReg motorReg;

void printMotorStatus(void) {
    printf("Motor Status: start=%d, stop=%d, reverse=%d, fault=%d, raw=0x%02X\n",
           motorReg.bits.start,
           motorReg.bits.stop,
           motorReg.bits.reverse,
           motorReg.bits.fault,
           motorReg.all);
}

int main(void) {
    printf("=== Điều khiển động cơ ===\n");

    // Bật động cơ
    motorReg.bits.start = 1;
    // Không đảo chiều
    motorReg.bits.reverse = 0;
    // Dừng động cơ (không dừng)
    motorReg.bits.stop = 0;
    // Không báo lỗi
    motorReg.bits.fault = 0;

    printMotorStatus();

    // Ghi trực tiếp cả byte
    motorReg.all = 0x0F;  // 00001111b → start=1, stop=1, reverse=1, fault=1

    printMotorStatus();

    return 0;
}
```
**Kết Quả**
```c
=== Điều khiển động cơ ===
Motor Status: start=1, stop=0, reverse=0, fault=0, raw=0x01
Motor Status: start=1, stop=1, reverse=1, fault=1, raw=0x0F
```

### **chuyển đổi dữ liệu (byte ↔ int ↔ float)**
```c
#include <stdio.h>
#include <stdint.h>

// Union dùng để chuyển đổi giữa float, int, và byte array
typedef union {
    float f;            // 4 byte float
    uint32_t i;         // 4 byte integer
    uint8_t bytes[4];   // 4 byte riêng lẻ
} Dataconverter;

int main(void) {
    Dataconverter data;

    // Gán giá trị float
    data.f = 3.14159f;

    printf("=== chuyển đổi từ float ===\n");
    printf("Float: %f\n", data.f);
    printf("Integer: 0x%08X\n", data.i);
    printf("Bytes: %02X %02X %02X %02X\n", data.bytes[0], data.bytes[1], data.bytes[2], data.bytes[3]);

    // Giả sử truyền nhận dữ liệu, ta chỉ có 4 bytes:
    uint8_t received_bytes[4] = { 0xDB, 0x0F, 0x49, 0x40 }; // Dữ liệu float 3.14159 dạng byte

    // copy vào data
    for (int i = 0; i < 4; i++) {
        data.bytes[i] = received_bytes[i];
    }

    printf("\n=== Sau khi nhận từ 4 bytes ===\n");
    printf("Float: %f\n", data.f);
    printf("Integer: 0x%08X\n", data.i);

    return 0;
}
```
**Kết Quả**
```c
=== chuyển đổi từ float ===
Float: 3.141590
Integer: 0x40490FDB
Bytes: DB 0F 49 40

=== Sau khi nhận từ 4 bytes ===
Float: 3.141590
Integer: 0x40490FDB
```
Bạn gán cho data.f giá trị float 3.14159.

Trong máy tính, float không lưu dưới dạng số thập phân như bạn nghĩ, mà nó mã hóa theo chuẩn IEEE-754 (chuẩn số thực dấu phẩy động 32-bit).

✅ Số 3.14159 trong chuẩn IEEE-754 (float 32-bit) có dạng hex là: `0x40490FDB`

### **Tối ưu bộ nhớ**
```c
#include <stdio.h>

typedef union {
    int intValue;
    float floatValue;
    char str[20];
} Data;

int main() {
    Data data;

    data.intValue = 42;
    printf("Integer: %d\n", data.intValue);

    data.floatValue = 3.14;
    printf("Float: %.2f\n", data.floatValue);

    return 0;
}
```
### **Làm việc với giao tiếp ngoại vi (UART, SPI, I2c, LoRa, cAN, Modbus...)**
```c
#include <stdio.h>
#include <stdint.h>  // Thư viện dùng kiểu uint8_t, uint16_t chuẩn

// Định nghĩa kiểu dữ liệu Union để truy cập 2 byte của một từ 16-bit
typedef union {
    struct {
        uint8_t lowByte;     // Byte thấp (8 bits đầu tiên)
        uint8_t highByte;    // Byte cao (8 bits tiếp theo)
    } bytes;
    uint16_t word;           // Toàn bộ 16 bits
} SPI_Data;

int main() {
    SPI_Data spiData;

    // Gán giá trị 16-bit cho word
    spiData.word = 0xABcD;   // 0xAB là high byte, 0xcD là low byte

    // In ra từng byte
    printf("Word: 0x%04X\n", spiData.word);
    printf("High Byte: 0x%02X\n", spiData.bytes.highByte);
    printf("Low Byte: 0x%02X\n", spiData.bytes.lowByte);

    return 0;
}
```


