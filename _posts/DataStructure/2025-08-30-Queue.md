---
title: "Queue"
date: 2025-08-30 21:22:00 +0800
categories: [Data Structure]
tags: [Data Structure]
---

# � Tổng quan về Queue

## 🎯 Khái niệm cơ bản

Hàng đợi (tiếng Anh: Queue) là một cấu trúc dữ liệu dùng để lưu giữ các đối tượng theo cơ chế FIFO (viết tắt từ tiếng Anh: First In First Out), nghĩa là "vào trước ra trước".

## 🌟 Ví dụ thực tế

Hình ảnh về hàng đợi rất hay gặp trong đời sống hàng ngày. 
**Ví dụ điển hình nhất là việc xếp hàng:**
- Người vào đầu tiên sẽ được tiếp đón đầu tiên
- Người mới vào bắt buộc phải xếp hàng ở phía cuối

![Queue Example](/assets/DataStructure/Queue/example.png)

## 🔄 Nguyên tắc hoạt động

Trong cấu trúc hàng đợi (queue), ta chỉ có thể:
1. Thêm phần tử vào một đầu của queue (gọi là cuối - rear)
2. Xóa phần tử ở đầu còn lại của queue (gọi là đầu - front)

> ⚠️ **Lưu ý**: Ở một đầu không thể xảy ra hai hành động thêm và xóa đồng thời.

## 🛠️ Các thao tác cơ bản

| Operation | Description                                                        | Time Complexity | Space Complexity |
|-----------|--------------------------------------------------------------------|-----------------|------------------|
| **Enqueue** | Chèn một phần tử vào Queue thông qua rear pointer.              | O(1)            | O(1)             |
| **Dequeue** | Xóa một phần tử từ Queue thông qua front pointer           | O(1)            | O(1)             |
| **Peek**    | Trả về phần tử đầu của Queue                            | O(1)            | O(1)             |
| **IsFull**  | Trả về true nếu Queue đã đầy, ngược lại thì false         | O(1)            | O(1)             |
| **IsEmpty** | Trả về true nếu Queue trống, ngược lại thì false        | O(1)            | O(1)             |

![Queue Example](/assets/DataStructure/Queue/queue_operator.png)

## 💫 Các loại Queue phổ biến

1. **Simple Queue (Queue đơn giản)** 📝
   - Thêm từ rear, lấy từ front
   - Hoạt động FIFO cơ bản

2. **Circular Queue (Queue vòng)** 🔄
   - Sử dụng không gian hiệu quả hơn
   - Khi rear đến cuối, quay lại đầu mảng

3. **Priority Queue (Queue ưu tiên)** ⭐
   - Phần tử có độ ưu tiên cao được xử lý trước
   - Thường dùng trong lập lịch CPU

4. **Double Ended Queue (Deque)** ↔️
   - Có thể thêm/xóa ở cả hai đầu
   - Linh hoạt hơn queue thông thường

## Queue Initialization Note

**Linear Queue**
  - Khởi tạo: `front = rear = -1`
  - Ý nghĩa: `-1` biểu thị hàng đợi rỗng.  
  - Khi enqueue lần đầu → `front = rear = 0`.

**Circular Queue**
  - Khởi tạo: `front = -1, rear = 0`
  - Ý nghĩa: `front` trỏ trước phần tử đầu tiên, `rear` trỏ tới ô trống tiếp theo.  
  - Giúp tận dụng tối đa mảng khi queue chạy vòng tròn.

## 🛠️ Ví dụ thực tế về Queue

### 1. Circular Queue
```c
typedef struct {
    int data[MAX_SIZE];
    int front, rear;
} CircularQueue;

void enqueue(CircularQueue* q, int value) {
    if ((q->rear + 1) % MAX_SIZE == q->front) {
        printf("Queue đầy!\n");
        return;
    }
    if (q->front == -1) q->front = 0;
    q->rear = (q->rear + 1) % MAX_SIZE;
    q->data[q->rear] = value;
}
```

### 2. Priority Queue
```c
typedef struct {
    int data;
    int priority;
} Item;

typedef struct {
    Item items[MAX_SIZE];
    int size;
} PriorityQueue;

void enqueue(PriorityQueue* q, int data, int priority) {
    Item item = {data, priority};
    int i;
    for (i = q->size - 1; i >= 0; i--) {
        if (q->items[i].priority > priority)
            q->items[i + 1] = q->items[i];
        else break;
    }
    q->items[i + 1] = item;
    q->size++;
}
```

## 🎯 Ứng dụng trong thực tế

1. **Xử lý tác vụ** 💻
   - Quản lý in ấn (Print Queue)
   - Xử lý yêu cầu web server
   - Buffer trong streaming

2. **Giải thuật** 🧮
   - BFS (Breadth First Search)
   - Dijkstra's algorithm
   - CPU Scheduling

3. **Hệ điều hành** ⚙️
   - Process Scheduling
   - Memory Management
   - I/O Buffer Management

## ⚠️ Các vấn đề cần lưu ý

1. **Queue Overflow**
   - Xảy ra khi queue đầy
   - Giải pháp: Dùng circular queue hoặc dynamic queue

2. **Queue Underflow**
   - Xảy ra khi dequeue queue rỗng
   - Cần kiểm tra isEmpty trước khi dequeue

3. **Memory Management**
   - Cần giải phóng bộ nhớ khi dùng dynamic queue
   - Tránh memory leak

## 🔍 So sánh các loại Queue

| Loại Queue | Ưu điểm | Nhược điểm |
|------------|---------|------------|
| Simple Queue | Dễ implement | Lãng phí bộ nhớ |
| Circular Queue | Tối ưu bộ nhớ | Phức tạp hơn |
| Priority Queue | Linh hoạt | Tốn thời gian sắp xếp |
| Deque | Đa năng | Phức tạp trong quản lý |

## 💡 Tips và Tricks

1. **Tối ưu hiệu năng**
   ```c
   // Dùng macro thay vì hàm cho các thao tác đơn giản
   #define isEmpty(q) ((q)->size == 0)
   #define isFull(q) ((q)->size == MAX_SIZE)
   ```

2. **Xử lý lỗi an toàn**
   ```c
   int dequeue(Queue* q) {
       if (isEmpty(q)) {
           // Trả về giá trị đặc biệt hoặc throw exception
           return QUEUE_EMPTY;
       }
       // Xử lý bình thường
   }
   ```

3. **Debug hiệu quả**
   ```c
   void printQueue(Queue* q) {
       printf("Front[%d]->", q->front);
       for(int i = q->front; i <= q->rear; i++)
           printf("%d ", q->data[i]);
       printf("<-Rear[%d]\n", q->rear);
   }
   ```