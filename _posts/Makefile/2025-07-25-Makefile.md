---
title: "Makefile"
date: 2025-07-25 21:26:00 +0800
categories: [Makefile]
tags: [Makefile]
---

# Makefile

## Tại sao lại có makefile?
![alt text](/assets/makefile/makefile.png)
- Trong một chương trình lón, nhiều driver nhưng khi build thì phải theo trình tự build process như hình bên dưới. Dẫn đến trường hợp khi build số lượng file lớn thì gõ đi gõ lại nhiều lần nên makefile sinh ra để giải quyết điều này.
![alt text](/assets/makefile/build_process.png)

### running the example
```makefile
hello:
	echo "Tran Cong Hoa"
```
result:
![alt text](/assets/makefile/make_example1.png)

### Cu phap Makefile
- Makefile bao gồm tập hợp các rule (quy tắc). Mỗi rule thường có dạng:
```makefile
targets: prerequisites
	command
	command
	command
```
- **Targets** là tên của các tệp tin, được phân tách bằng dấu cách.
- **Command** là một chuỗi các bước được dùng để tạo ra target.
- **Prerequisites** là tên các tệp tin, được phân tách bằng dấu cách. Các tệp này cần tồn tại trước khi các lệnh được thực thi để tạo ra mục tiêu. Chúng còn được gọi là dependencies (các phụ thuộc).

### Ban chat cua makefile
```makefile
hello:
	echo "Hello, World"
	echo "This line will print if the file hello does not exist."
```
- Ở đây có mục tiêu (target) là hello
- Mục tiêu có 2 lệnh (command).
- Mục tiêu không có phần phụ thuộc (dependencies).

#### VD2:
- Toi co file ".c"
```c
#include <stdio.h>

int main(){
    printf("Hello, World!\n");
    return 0;
}
```
trong makefile
```makefile
hello:
	gcc main.c -o hello
```

Khi chạy lệnh make, vì không có target nào được cung cấp, nên target đầu tiên (hello) sẽ được thực thi. Lần đầu chạy, Make sẽ chạy các lệnh và tạo ra file hello.

Tuy nhiên, lần thứ hai chạy, Make sẽ thấy file hello đã tồn tại, nên sẽ không thực thi lại và hiện thông báo:
```makefile
make: 'hello' is up to date.
```

Vấn đề ở đây là: nếu có một file **.c** nào đó bị sửa đổi (chẳng hạn hello.c), thì khi chạy make cũng không tái biên dịch, vì Make không biết rằng file **.c** đó là một dependencies của hello.
```makefile
hello: main.c
	gcc main.c -o hello
```
Khi chạy thì nó chỉ chạy nếu như hello chưa tồn tại hoặc đã tồn tại nhưng main.c có sự thay đổi khác với hello đã biên dịch trước đó.

Hiểu rõ điều này có thể được giải thích, Make sử dụng timestamp của hệ thống tập tin để xác định xem có thứ gì bị thay đổi không. Vì timestamp của tập tin thường chỉ thay đổi khi tập tin bị chỉnh sửa.

Điều này cũng không hẳn đúng vì có thể chỉnh sửa timestamp thành thời gian cũ hơn thì Make sẽ hiểu không có gì thay đổi mới hơn.

### Make clean
clean thì thường được sử dụng để xóa các file output của những target khác. Có thể chạy make và make clean để tạo và xóa toàn bộ file.

clean sẽ không bao giờ được thực thi trừ khi gọi make clean.

```makefile
files: 
	touch some_files

clean:
	rm -f some_files
```

### Variables
Bien chi la strings. Thuong su dung :=, =.
#### VD5:

```makefile
files := file1 file2
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file
```
Đơn hoặc đôi thì không có ý nghĩa trong Make. Chúng chỉ là các ký tự gán cho biến.

```makefile
a := one two# a is set to the string "one two"
b := 'one two' # Not recommended. b is set to the string "'one two'"
all:
	printf '$a'
	printf $b
```
Các biến tham chiếu bằng **${}** hoặc **$()** có dấu.

```makefile
x := dude

all:
	echo $(x)
	echo ${x}

	# Bad practice, but works
	echo $x 
```
## Targets
### The all target
#### VD:
Tạo ra nhiều target nhưng chạy chung cùng một lúc.
```makefile
all: one two three

one:
	touch one
two:
	touch two
three:
	touch three

clean:
	rm -f one two three
```
### Multiple targets

```makefile
all: f1.o f2.o

f1.o f2.o:
	echo $@
```
Kết quả chạy là:
```makefile
 ⚡loo ❯❯ make all
echo f1.o
f1.o
echo f2.o
f2.o
```
## Automatic Variables and Wildcards
### Wildcard
Cả hai ** * ** và ** % ** gọi là wildcards trong Make, nhưng hai cái có ý nghĩa khác nhau. ** * ** tìm kiếm file trong hệ thống của bạn giống tên filenames.

### * Wildcard
Phải bọc nó trong hàm wildcard, bởi vì sẽ dính một lỗi phổ biến dưới đây.
```makefile
# Print out file information about every .c file
print: $(wildcard *.c)
	ls -la  $?
```
Không dùng trong lúc định nghĩa biến
##### VD:
```makefile
SRC = *.c
```
Nếu không có file .c nào trong thư mục thì nó sẽ giữ nguyên và hiểu là chuỗi *.c, cho nên nên dùng hàm **wildcard**.

```makefile
thing_wrong := *.o # Don't do this! '*' will not get expanded
thing_right := $(wildcard *.o)

all: one two three four

# Fails, because $(thing_wrong) is the string "*.o"
one: $(thing_wrong)

# Stays as *.o if there are no files that match this pattern :(
two: *.o 

# Works as you would expect! In this case, it does nothing.
three: $(thing_right)

# Same as rule three
four: $(wildcard *.o)
```
### % Wildcard
Dấu % thật sự rất hữu ích, nhưng hơi gây nhầm lẫn vì nó có thể được sử dụng trong nhiều tình huống khác nhau.
- Khi dùng ở chế độ "so khớp" (matching), ** % ** sẽ khớp với một hoặc nhiều ký tự trong một chuỗi. Phần chuỗi khớp này được gọi là stem (thân chuỗi).
```makefile
%.o: %.c
	gcc -c $< -o $@
```
Ở đây:

** % ** khớp với phần stem là main

** % ** trong %.o nghĩa là main.o

** % **  trong %.c nghĩa là main.c

- Khi dùng ở chế độ "thay thế" (replacing), ** % **sẽ lấy phần stem đã khớp được và thay thế nó vào chuỗi khác.
```makefile
SRC = main.c utils.c math.c
OBJ = $(patsubst %.c, %.o, $(SRC))
```
Kết quả:
```makefile
OBJ = main.o utils.o math.o
```
- ** % ** thường được dùng nhất trong định nghĩa rule (luật/phép xây dựng) và trong một số hàm đặc biệt.

### Automatic Variables
```makefile
hey: one two
	# Outputs "hey", since this is the target name
	echo $@

	# Outputs all prerequisites newer than the target
	echo $?

	# Outputs all prerequisites
	echo $^

	# Outputs the first prerequisite
	echo $<

	touch hey

one:
	touch one

two:
	touch two

clean:
	rm -f hey one two
```

## FANCY RULE
### Implicit Rules
Những rule ngầm của makefile thường được dùng. Cần nên biết:
- Biên dịch một chương trình C: **n.o** được tạo ra tự động từ **n.c** hoặc **n.cpp** với một command.
```makefile
$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@
```
- Biên dịch một chương trình C++: **n.o** thì được tự động tạo ra từ **n.c** hoặc **n.cpp** với command.
```makefile
$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@
```
- Liên kết đối tượng duy nhất: n được tạo ra tự động từ **n.o** bằng cách chạy lệnh.
```makefile
$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@
```
Những variable được sử dụng trong implicit rules là:
- **CC**: chương trình cho biên dịch chương trình C; mặc định cc
- **CXX**: chương trình biên dịch C++; mặc định g++
- **CFLAGS**: flag mở rộng cho trình biên dịch C.
- **CXXFLAGS**: flag mở rộng cho trình biên dịch C++.
- **CPPFLAGS**: flag mở rộng cho tiền xử lý C.
- **LDFLAGS**: Các flag bổ sung truyền cho trình biên dịch khi nó được yêu cầu gọi trình liên kết (linker).

```makefile
CC = gcc # Flag for implicit rules
CFLAGS = -g # Flag for implicit rules. Turn on debug info

# Implicit rule #1: blah is built via the C linker implicit rule
# Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists
blah: blah.o

blah.c:
	echo "int main() { return 0; }" > blah.c

clean:
	rm -f blah*
```
### Static Pattern Rules
Static pattern rules là một cách viết khác ít hơn trong một Makefile.
Cú pháp ở dưới đây:
```makefile
targets...: target-pattern: prereq-patterns ...
   commands
```
Bản chất là target khớp với target-pattern (thông qua % wildcard). Bất cứ những khớp đó gọi là stem. Stem này thay thế prereq-pattern, để tạo ra những điều kiện tiền quyết cho target.

Một cách sử dụng thông thường để biên dịch **.c** vào **.o**.
```makefile
objects = foo.o bar.o all.o
all: $(objects)
	$(CC) $^ -o all

foo.o: foo.c
	$(CC) -c foo.c -o foo.o

bar.o: bar.c
	$(CC) -c bar.c -o bar.o

all.o: all.c
	$(CC) -c all.c -o all.o

all.c:
	echo "int main() { return 0; }" > all.c

# Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.
%.c:
	touch $@

clean:
	rm -f *.c *.o all
```
Ở đây là một cách hiệu quả hơn, sử dụng static pattern rule:
```makefile
objects = foo.o bar.o all.o
all: $(objects)
	$(CC) $^ -o all

# Syntax - targets ...: target-pattern: prereq-patterns ...
# In the case of the first target, foo.o, the target-pattern matches foo.o and sets the "stem" to be "foo".
# It then replaces the '%' in prereq-patterns with that stem
$(objects): %.o: %.c
	$(CC) -c $^ -o $@

all.c:
	echo "int main() { return 0; }" > all.c

# Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.
%.c:
	touch $@

clean:
	rm -f *.c *.o all
```